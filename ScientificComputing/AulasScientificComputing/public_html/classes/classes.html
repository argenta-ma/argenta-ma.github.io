<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">  
        <meta content="IE=edge" http-equiv="X-UA-Compatible"> 
        <meta content="width=device-width,initial-scale=1" name="viewport"> 
        <meta content="Aulas de introcução à computação científica." name="description"> 
        <meta content="Markinho" name="author"> 
        
        <title> Introdução a Classes </title> 
        
        <link href="./css/bootstrap.min.css" rel="stylesheet">        
        <link href="./css/docs.min.css" rel="stylesheet">
        <link href="./css/carbonads.css" rel="stylesheet">
        <link href="./css/prism.css" rel="stylesheet">
        
        <link href="../imagens/favicon.ico" rel="icon"> 
        
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
        </script>
        <script type="text/javascript" async
            src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
        </script>
        
    </head>
    <body>
        
        <!-- Cabeçalho -->
        <div class="v4-tease">
            <a href="http://www.estruturas.ufpr.br">
                <img style="position: absolute; top: 0; left: 0; border: 0;" 
                     src="../imagens/estruturasUFPR.png" alt="Voltar para Estruturas.UFPR">
            </a>
            <a class="navbar-brand" style="position: absolute; left: 360px;" href="../index.html">
                Aulas de Introdução a Computação Científica
            </a>
        </div>
         <!-- FINAL Cabeçalho -->
        
        <!-- Menu superior -->
        <header class="bs-docs-nav navbar navbar-static-top" id="top"> 
            <div class="container"> 
                <div class="navbar-header"> 
                    <button aria-controls="bs-navbar"  
                            class="collapsed navbar-toggle" data-target="#bs-navbar" 
                            data-toggle="collapse" type="button"> 
                        <span class="sr-only">Alternar Navegação</span> 
                        <span class="icon-bar"></span> 
                        <span class="icon-bar"></span> 
                        <span class="icon-bar"></span> 
                    </button>
                </div> 
                <nav class="collapse navbar-collapse" id="bs-navbar"> 
                    <ul class="nav navbar-nav"> 
                        <li class="active"> <a href="lacoslistas.html">Introdução a Classes</a> </li>
                        <li><a href="#final">Tarefa</a></li>
                    </ul> 
                    <ul class="nav navbar-nav navbar-right"> 
                        <li class="dropdown" id="accountmenu">
                            <a class="dropdown-toggle" data-toggle="dropdown" href="#">Demais tópicos abordados<b class="caret"></b></a>
                            <ul class="dropdown-menu">
                                <li><a href="../index.html#___sec0">Programando equações</a></li>
                                <li><a href="../index.html#___sec1">Laços e listas</a></li>
                                <li><a href="../index.html#___sec2">Funções e ramificações</a></li>
                                <li><a href="../index.html#___sec3">Entrada do usuário e manipulação de erros</a></li>
                                <li><a href="../index.html#___sec4">Arranjos e gráficos de curvas</a></li>            
                                <li><a href="../index.html#___sec6">Dicionários e cadeias de caracteres</a></li>
                                <li><a href="../index.html#___sec7">Introdução a Classes</a></li>            
                                <li><a href="../index.html#___sec9">Programação orientada a objeto</a></li>
                                <li><a href="../index.html#___sec10">Números aleatórios e jogos simples</a></li>
                                <li><a href="../index.html#___secA">Sequências e relações de recorrência</a></li>
                                <li><a href="../index.html#___secB">Programação de equações diferenciais</a></li>
                                <li><a href="../index.html#___secC">Gráficos tridimensionais</a></li>
                                <li><a href="../index.html#___secD">Programação em paralelo</a></li>
                                <li><a href="../index.html#___secE">Interfaces gráficas de usuário (GUI)</a></li>
                                <li><a href="../index.html#___secF">Migrando Python para código compilado</a></li> 
                            </ul>
                        </li> 
                    </ul> 
                </nav> 
            </div> 
        </header>
        <!-- FINAL MENU SUPERIOR -->
        
        <!-- Painel Superior -->
        <div class="bs-docs-header" id="content" tabindex="-1"> 
            <div class="container"> 
                <h1>Introdução a Classes</h1> 
                <p>Dividir para conquistar.<br>
                <font size="2px">Prof. Marco André Argenta / PPGECC / UFPR</font></p>
                <div id="carbonads-container">
                    <div class="carbonad">
                        <div id="azcarbon">
                            <a href="./imagens/programando_equacoes.png" target="_blank">
                                <!-- Imagens em 120 px altura e 300 px largura -->
                                <img src="./imagens/classes.png" class="carbonad-image carbonad-img">
                            </a>
                        </div>
                    </div>
                </div> 
            </div> 
        </div>
        <!-- FINAL PAINEL SUPERIOR -->
        
        <!-- Parte principal -->
        <div class="container bs-docs-container">
            <div class="row">
                
                <!-- Conteúdo Principal -->
                <div class="col-md-9" role="main">
                    <div class="bs-docs-section"> 
                        <h1 class="page-header" id="inicio">Introdução a Classes</h1> 
                        <div class="well">
                            Uma classe empacota um conjunto de dados (variáveis) com um 
                            conjunto de funções que operam sobre esses dados. O objetivo é
                            alcançar um código mais modular através do agrupamento de dados
                            e funções em unidades gerenciáveis (normalmente pequenas). A 
                            maioria dos cálculos matemáticos podem ser programados facilmente
                            sem o uso de classes, mas em vários problemas, classes tornam
                            as soluções mais elegantes e/ou deixam o código mais fácil
                            de ser estendido a um novo estágio. No mundo não matemático, existem
                            conceitos e algoritmos a eles associados que ajudam a estruturar a solução
                            de um problema. Classes podem ajudar no entendimento do problema
                            e contribuir para simplificar a modelagem dos dados e as ações em 
                            programas.
                        </div>               
                    </div>
                    <div class="bs-docs-section" id="introducao_classes">
                        <h1 class="page-header">O básico de classes</h1>

                        <p><b>Classe = funções + dados(variáveis) em uma unidade</b></p>
                        <ul>
                            <li>Uma classe empacota dados (uma coleção de variáveis)
                            e funções em uma simples unidade;</li>
                            <li>Como um programador você pode criar uma nova classe
                            e desse modo um novo tipo de objeto (como float, lista, arquivo,...);</li>
                            <li>Uma classe é muito parecida com um módulo: uma
                            coleção de variáveis "globais" e funções que pertencem
                            a um mesmo escopo;</li>
                            <li>Existe uma instância de um módulo enquanto uma classe
                            pode ter muitas instâncias (cópias);</li>
                            <li>Programação moderna aplica classes sempre que possível;</li>
                            <li>Vai tomar algum tempo para dominar o conceito de classes;</li>
                            <li>Vamos aprender fazendo!</li>
                        </ul>
                        
                    </div>
                    <div class="bs-docs-section" id="classe_funcao">
                        <h1 class="page-header">Representando uma função por uma
                        classe</h1>
                        <h3>O fundamento</h3>

                        <p>Considere uma função de $t$ com um parâmetro $v_0$:</p>
                        $$ y(t; v_0)=v_0t - {1\over2}gt^2$$
                        
                        <p>Precisamos de $v_0$ e $t$ para avaliar $y$ (e $g = 9,81$),
                        mas como devemos implementar isso?</p>
                        
                        <p><b>Tendo $t$ e $v_0$ como argumentos:</b></p>
                        <pre><code class="language-python">
def y(t, v0):
    g = 9.81
    return v0*t - 0.5*g*t**2
                        </code></pre>
                        
                        <p><b>Tento $t$ como argumento e $v_0$ como variável 
                            global:</b></p>
                        <pre><code class="language-python">
def y(t):
    g = 9.81
    return v0*t - 0.5*g*t**2
                        </code></pre>
                        <p>Motivação: $y(t)$ é uma função de $t$ apenas.</p>
                        <h3>A idéia</h3>

                        <ul>
                            <li>Com uma classe, $y(t)$ pode ser uma função de $t$ apenas,
                            mas ainda tem $v_0$ e $g$ como parâmetros com valores dados;</li>
                            <li>A classe empacota uma função $y(t)$ e os dados $(v_0, g)$.</li>
                        </ul>
                        
                        <h3>A visão técnica</h3>

                        <ul>
                            <li>Faremos uma classe <code>Y</code> para $y(t; v_0)$
                            com variáveis $v_0$ e $g$ e uma função de $t$ para calcular
                            $y(t; v_0)$;</li>                                
                            <li>Qualquer classe deve também ter uma função <code>__init__</code>
                            para a inicialização das variáveis.</li>
                        </ul>
                        <div class="text-center">
                            <img src="./imagens/UML_class_Y.png" alt="UML">
                        </div>
                        
                        <h3>O código</h3>
                        
                        <pre><code class="language-python">
class Y:
    def __init__(self, v0):
        self.v0 = v0
        self.g = 9.81
    def valor(self, t):
        return self.v0*t - 0.5*self.g*t**2
                        </code></pre>
                        <p>Uso:</p>
                        <pre><code class="language-python">
y = Y(v0=3)            # cria a instância (objeto)
v = y.valor(0.1)       # calcule o valor da função
                        </code></pre>
                        
                        <h3>O construtor</h3>
                        
                        <p>Quando escrevemos:</p>
                        <pre><code class="language-python">
y = Y(v0=3)            # cria a instância (objeto)
                        </code></pre>
                        <p>criamos uma nova variável (instância) <code>y</code>
                            do tipo <code>Y</code>. <code>Y(3)</code> é uma chamada
                        ao construtor:</p>
                        <pre><code class="language-python">
class Y:
    def __init__(self, v0):
        self.v0 = v0
        self.g = 9.81
                        </code></pre>
                    </div>
                    <div class="bs-docs-section" id="classe_self">
                        <h1 class="page-header">O que é essa tal de 
                            variável <code>self</code>?</h1>

                        <p>Fique calmo, isso será entendido mais a frente quando
                        você se acostumar com ele!</p>
                        
                        <ul>
                            <li>Pense no <code>self</code> como <code>y</code>, a nova
                                variável a ser criada. <code>self.v0 = ...</code>
                                significa que nos anexamos a variável <code>v0</code>
                                a <code>self(y)</code>;</li>
                            <li><code>Y(3)</code> significa <code>Y.__init__(y, 3)</code>,
                                isto é, definir <code>self = y</code>, <code>v0 = 3</code>;</li>
                            <li>Lembre-se: <code>self</code> é sempre o primeiro parâmetro
                            em uma função, mas nunca inserido na chamada!</li>
                            <li>Após <code>y = Y(3)</code>, <code>y</code> tem duas
                                variáveis <code>v0</code> e <code>g</code>.</li>
                        </ul>
                        <blockquote>
In mathematics you don't understand things. You just get used to them. John von Neumann, mathematician, 1903-1957.
                        </blockquote>
                        <p>* Em matemática você não entende as coisas. Você apenas
                        se acostuma a elas.</p>
                        
                    </div>
                    <div class="bs-docs-section" id="rep_class_func_cont">
                        <h1 class="page-header">Representando uma função por uma
                        classe</h1>
                        <h3>O método valor</h3>
                        
                        <ul>
                            <li>Funções em classes são chamadas de métodos;</li>
                            <li>Variáveis em classes são chamadas de atributos.</li>
                        </ul>
                        <p>Aqui está o método valor:</p>
                        <pre><code class="language-python">
def valor(self, t):
    return self.v0*t - 0.5*self.g*t**2
                        </code></pre>
                        <p>Exemplo em uma chamada:</p>
                        <pre><code class="language-python">
v = y.valor(t=0.1)
                        </code></pre>
                        <p><code>self</code> é deixado fora da chamada, mas o Python
                            insere <code>y</code> automaticamente como o
                            argumento <code>self</code> dentro do método de valor.</p>
                        <p>Pense na chamada como:</p>
                        <pre><code class="language-python">
Y.valor(y, t=0.1)
                        </code></pre>
                        <p>Dentro de <code>valor</code> as coisas "aparecem" como:</p>
                        <pre><code class="language-python">
return y.v0*t - 0.5*y.g*t**2
                        </code></pre>
                        <p><code>self</code> dá acesso às "variáveis globais"
                        do objeto classe.</p>
                        
                        <h3>Resumo do objeto classe</h3>
                        <ul>
                            <li>A classe <code>Y</code> coleta os atributos
                                <code>v0</code> e <code>g</code> e o método
                                <code>valor</code> como uma unidade;</li>
                            <li><code>valor(t)</code> é uma função de <code>t</code>
                            apenas, mas tem acesso automático aos parâmetros
                            <code>v0</code> e <code>g</code> como <code>self.v0</code>
                            e <code>self.g</code> respectivamente;</li>
                            <li>A grande vantagem: podemos enviar <code>y.valor</code>
                                como uma função ordinária de <code>t</code> à qualquer
                                outra função que espera uma função <code>f(t)</code>
                            de uma variável:</li>
                        </ul>
                        <pre><code class="language-python">
def fazer_tabela(f, t_fim, n):
    for t in np.linspace(0, t_fim, n):
        print t, f(t)

def g(t):
    return np.sin(t)*np.exp(-t)

fazer_tabela(g, 2*pi, 101)         # enviar uma função normal

y = Y(6.5)
fazer_tabela(y.valor, 2*pi, 101)   # enviar um método de uma classe
                        </code></pre>
                        
                        <h3>O caso genérico</h3>
                        <p>Dada uma função com \( n+1 \) parâmetros e uma
                        variável independente,</p>
                        $$ f(x; p_0,\ldots,p_n)$$
                        <p>é elegante e esperto representar $f$ por uma classe
                        onde \( p_0,\ldots,p_n \) são atributos e que tenha um método,
                        digamos, <code>valor(self, x)</code> para calcular \( f(x) \).</p>
                        <pre><code class="language-python">
class MinhaFuncao:
    def __init__(self, p0, p1, p2, ..., pn):
        self.p0 = p0
        self.p1 = p1
        ...
        self.pn = pn

    def valor(self, x):
        return ...
                        </code></pre>
                    </div>
                    <div class="bs-docs-section" id="funcao_4_par">
                        <h1 class="page-header">Class para uma função com 4 parâmetros</h1>

                        $$ v(r; \beta, \mu_0, n, R) = \left({\beta\over 2\mu_0}\right)^{{1\over n}} {n \over n+1}\left( R^{1 + {1\over n}} - r^{1 + {1\over n}}\right) $$
                        
                        <pre><code class="language-python">
class PerfilVelocidades:
    def __init__(self, beta, mu0, n, R):
        self.beta, self.mu0, self.n, self.R = \
        beta, mu0, n, R

    def valor(self, r):
        beta, mu0, n, R = \
        self.beta, self.mu0, self.n, self.R
        n = float(n)  # garantir as divisões por float
        v = (beta/(2.0*mu0))**(1/n)*(n/(n+1))*\
            (R**(1+1/n) - r**(1+1/n))
        return v

v = PerfilVelocidades(R=1, beta=0.06, mu0=0.02, n=0.1)
print v.valor(r=0.1)
                        </code></pre>
                        
                    </div>
                    <div class="bs-docs-section" id="calss_sintaxe_gen">
                        <h1 class="page-header">Sintaxe genérica de uma
                        classe em Python</h1>

                        <pre><code class="language-python">
class MinhaClasse:
    def __init__(self, p1, p2):
        self.atr1 = p1
        self.atr2 = p2

    def metodo1(self, arg):
        # pode-se iniciar um novo atributo fora do construtor:
        self.atr3 = arg
        return self.atr1 + self.atr2 + self.atr3

    def metodo2(self):
        print 'Oi!'

m = MinhaClasse(4, 10)
print m.metodo1(-2)
m.metodo2()
                        </code></pre>
                        <p>É comum iniciar todos os atributos no construtor, mas não
                        é uma obrigatoriedade. Os atributos podem ser iniciados
                        onde forem necessários!</p>
                        
                    </div>
                    <div class="bs-docs-section" id="self_de_novo">
                        <h1 class="page-header">Mas o que é a tal da variável
                            <code>self</code>, quero saber!</h1>

                        <p><b>Cuidado:</b></p>
                        <p>Você tem duas escolhas:</p>
                        <ul>
                            <li>Seguir as explicações detalhadas sobre o que 
                                <code>self</code> realmente é;</li>
                            <li>Deixar para aprender aos poucos e ir absorvendo
                                conforme a experiência (de reprente <code>self</code>
                            fica claro!).</li>
                        </ul>
                        <p>A sintaxe:</p>
                        <pre><code class="language-python">
y = Y(3)
                        </code></pre>
                        <p>Pode ser entendida como:</p>
                        <pre><code class="language-python">
Y.__init__(y, 3)   # o prefixo da classe Y é como um prefixo de módulo
                        </code></pre>
                        <p>Então:</p>
                        <pre><code class="language-python">
self.v0 = v0
                        </code></pre>
                        <p>É na verdade:</p>
                        <pre><code class="language-python">
y.v0 = 3
                        </code></pre>
                        
                    </div>
                    <div class="bs-docs-section" id="como_self_trabalha">
                        <h1 class="page-header">Como <code>self</code> trabalha no
                        método valor</h1>

                        <pre><code class="language-python">
y.v0 = 3
                        </code></pre>
                        <p>Pode ser alternativamente escrito como:</p>
                        <pre><code class="language-python">
v = Y.valor(y, 2)
                        </code></pre>
                        <p>Então, nós fazemos <code>instance.method(arg1, arg2), self</code>
                            se tornar <code>instance</code> dentro de <code>method</code>.</p>
                        
                    </div>
                    <div class="bs-docs-section" id="multiplas_instancias">
                        <h1 class="page-header">Trabalhando com múltiplas instâncias
                            pode ajudar a explicar <code>self</code></h1>

                        <p><code>id(obj)</code>: mostra o identificador Python único
                        de um objeto:</p>
                        <pre><code class="language-python">
class ExploradorDeSiMesmo:
    """Classe para calcular a*x."""
    def __init__(self, a):
        self.a = a
        print 'init: a=%g, id(self)=%d' % (self.a, id(self))

    def valor(self, x):
        print 'valor: a=%g, id(self)=%d' % (self.a, id(self))
        return self.a*x
                        </code></pre>
                        <pre><code class="language-python">
>>> s1 = ExploradorDeSiMesmo(1)
init: a=1, id(self)=38085696
>>> id(s1)
38085696

>>> s2 = ExploradorDeSiMesmo(2)
init: a=2, id(self)=38085192
>>> id(s2)
38085192

>>> s1.valor(4)
valor: a=1, id(self)=38085696
4
>>> ExploradorDeSiMesmo.valor(s1, 4)
valor: a=1, id(self)=38085696
4

>>> s2.value(5)
value: a=2, id(self)=38085192
10
>>> SelfExplorer.value(s2, 5)
value: a=2, id(self)=38085192
10
                        </code></pre>
                    </div>
                    <div class="bs-docs-section" id="outro_exemplo_classe">
                        <h1 class="page-header">Um outro exemplo de Classe:
                        conta no banco</h1>

                        <ul>
                            <li>Atributos: nome, número da conta, saldo;</li>
                            <li>Métodos: depósito, saque, saída formatada.</li>
                        </ul>
                        <pre><code class="language-python">
class ContaBanco:
    def __init__(self, nome, numero_conta, deposito_inicial):
        self.nome = nome
        self.no = numero_conta
        self.saldo = deposito_inicial

    def deposito(self, movimentacao):
        self.saldo += movimentacao

    def saque(self, movimentacao):
        self.saldo -= movimentacao

    def info(self):
        s = '%s, %s, saldo: %s' % \
            (self.nome, self.no, self.saldo)
        print s
                        </code></pre>
                        <p>Exemplo de uso:</p>
                        <pre><code class="language-python">
>>> a1 = ContaBanco('Joaquim Porto', '19371554951', 20000)
>>> a2 = ContaBanco('Manuel Carvalho',  '19371564761', 20000)
>>> a1.deposito(1000)
>>> a1.saque(4000)
>>> a2.saque(10500)
>>> a1.saque(3500)
>>> print "a1's saldo:", a1.saldo
a1's saldo: 13500
>>> a1.info()
Joaquim Porto, 19371554951, saldo: 13500
>>> a2.info()
Manuel Carvalho, 19371564761, saldo: 9500
                        </code></pre>
                        
                    </div>
                    <div class="bs-docs-section" id="evitar_mau_uso">
                        <h1 class="page-header">Use o caractere <code>_</code>
                        para evitar o mau uso</h1>

                        <p>Possível, mas não intencionado ao uso:</p>
                        <pre><code class="language-python">
>>> a1.nome = 'Qualquer Outro Nome'
>>> a1.saldo = 100000
>>> a1.no = '19371564768'
                        </code></pre>
                        <p>As afirmações para o uso correto:</p>
                        <ul>
                            <li>Os atributos não devem ser modificados!</li>
                            <li>O atributo <code>saldo</code> pode ser visualizado.</li>
                            <li>Modificação do <code>saldo</code> é feita através
                                de <code>saque</code> ou <code>deposito</code>.</li>
                        </ul>
                        <p>Remédio:</p>
                        <p>Atributos ou métodos não intencionados ao uso fora da classe
                            podem ser marcados como protegidos através do prefixo <code>_</code>
                            antes de seu nome (ex.: <code>_nome</code>). Isso é apenas
                        uma convenção, não existe forma técnica de evitar que 
                        atributos e métodos seja acessados.</p>
                        <pre><code class="language-python">
class ContaBancoM:
    def __init__(self, nome, numero_conta, deposito_inicial):
        self._nome = nome
        self._no = numero_conta
        self._saldo = deposito_inicial

    def deposito(self, movimentacao):
        self._saldo += movimentacao

    def saque(self, movimentacao):
        self._saldo -= movimentacao

    def ver_saldo(self):    # NOVO - ver o valor do saldo
        return self._saldo

    def info(self):
        s = '%s, %s, saldo: %s' % \
            (self._nome, self._no, self._saldo)
        print s
                        </code></pre>
                        <p>Uso:</p>
                        <pre><code class="language-python">
a1 = ContaBancoM('Maria Albertina', '19371554951', 20000)
a1.saque(4000)

print a1._saldo     # funciona, mas quebra a convenção!

print a1.ver_saldo() # forma correta de ver o saldo

a1._no = '19371554955' # isso é "crime"!
                        </code></pre>
                    </div>                    
                    <div class="bs-docs-section" id="outro_exe_contatos">
                        <h1 class="page-header">Um outro exemplo: contatos</h1>

                        <ul>
                            <li>Contatos contém uma lista de dados de pessoas;</li>
                            <li>Dados de uma pessoa: nome, celular, telefone comercial,
                            telefone residencial, email;</li>
                            <li>Vamos criar uma classe para os dados sobre uma pessoa:</li>
                            <li>Métodos:
                                <ul>
                                    <li>Construtor para inicializar nome e outros dados;</li>
                                    <li>Adicionar novo número de  celular;</li>
                                    <li>Adicionar novo número comercial;</li>
                                    <li>Adicionar novo número residencial;</li>
                                    <li>Adicionar novo email;</li>
                                    <li>Escrever uma saída sobre os dados pessoais.</li>
                                </ul>
                            </li>
                        </ul>
                        <p>Código básico:</p>
                        <pre><code class="language-python">
class Pessoa:
    def __init__(self, nome,
                 num_celular=None, num_comercial=None,
                 num_residencial=None, email=None):
        self.nome = nome
        self.celular = num_celular
        self.comercial = num_comercial
        self.residencial = num_residencial
        self.email = email

    def ad_num_celular(self, numero):
        self.celular = numero

    def ad_num_comercial(self, numero):
        self.comercial = numero

    def ad_num_residencial(self, numero):
        self.residencial = numero

    def ad_email(self, endereco):
        self.email = endereco
                        </code></pre>
                        <p>Adicionando ao código um método de saída para mostrar
                    os dados de uma pessoa:</p>
                        <pre><code class="language-python">
class Pessoa:
    ...
    def saida(self):
        s = self.nome + '\n'
        if self.celular is not None:
            s += 'Telefone celular:   %s\n' % self.celular
        if self.comercial is not None:
            s += 'Telefone Comercial:   %s\n' % self.comercial
        if self.residencial is not None:
            s += 'Telefone Redidencial:  %s\n' % self.residencial
        if self.email is not None:
            s += 'Endereço de e-mail:  %s\n' % self.email
        print s
                        </code></pre>
                        <p>Uso:</p>
                        <pre><code class="language-python">
p1 = Pessoa('Hans Petter Langtangen', email='hpl@simula.no')
p1.ad_num_comercial('67828283'),
p2 = Pessoa('Marco André Argenta', num_comercial='33616447')
p2.ad_email('marco.argenta@ufpr.br')
contatos = [p1, p2]                           # lista
contatos = {'Langtangen': p1, 'Argenta': p2}   # bem melhor!
for p in contatos:
    contatos[p].saida()
                        </code></pre>
                    </div>
                    <div class="bs-docs-section" id="mais_um_ex">
                        <h1 class="page-header">Mais um exemplo: uma classe para
                        um círculo</h1>

                        <ul>
                            <li>Um círculo é definido pelo seu ponto central $x_0$, 
                            $y_0$ e seu raio $R$;</li>
                            <li>Esses dados podem ser atributos em uma classe;</li>
                            <li>Possíveis métodos na classe: <code>area</code>, 
                                <code>circunferencia</code>;</li>
                            <li>O construtor inicializa $x_0$, $y_0$ e $R$.</li>
                        </ul>
                        <pre><code class="language-python">
class Circulo:
    def __init__(self, x0, y0, R):
        self.x0, self.y0, self.R = x0, y0, R

    def area(self):
        return pi*self.R**2

    def circunferencia(self):
        return 2*pi*self.R
                        </code></pre>
                        <p>Uso:</p>
                        <pre><code class="language-python">
>>> c = Circulo(2, -1, 5)
>>> print 'Um círculo com raio %g e centro em (%g, %g) tem área %g' % \
...       (c.R, c.x0, c.y0, c.area())
Um círculo com raio 5 e centro em (2, -1) tem área 78.5398
                        </code></pre>
                        
                        <p>Para melhorar o código, podemos adicionar uma função
                            teste para a classe <code>circulo</code>:</p>
                         <pre><code class="language-python">
def test_Circulo():
    R = 2.5
    c = Circulo(7.4, -8.1, R)
    
    area_esperada = math.pi*R**2
    area_calculada = c.area()
    dif = abs(area_esperada - area_calculada)
    tol = 1E-14
    assert dif < tol, 'Problema no método Circulo.area, dif=%s' % dif

    circunferencia_esperada = 2*math.pi*R
    circunferencia_calculada = c.circunferencia()
    dif = abs(circunferencia_esperada - circunferencia_calculada)
    assert dif < tol, 'Problema no método Circulo.circunferencia, dif=%s' % dif
                        </code></pre>
                        <p>* não esqueça do <code>import math</code> no início 
                        do código!</p>
                        
                    </div>                    
                    <div class="bs-docs-section" id="metodos_especiais">
                        <h1 class="page-header">Métodos especiais</h1>
                        
                        <div class="text-center">
                            <img src="./imagens/special_methods1.jpg" alt="Métodos Especiais">
                        </div>

                        <pre><code class="language-python">
class MinhaClasse:
    def __init__(self, a, b):
    ...

p1 = MinhaClasse(2, 5)
p2 = MinhaClasse(-1, 10)

p3 = p1 + p2
p4 = p1 - p2
p5 = p1*p2
p6 = p1**7 + 4*p3
                        </code></pre>
                        <p>Métodos especiais permitem sintaxes diretas e são
                            reconhecidos pelos duplos <code>_</code> antes e depois 
                        do nome do método:</p>
                        <pre><code class="language-python">
def __init__(self, ...)
def __call__(self, ...)
def __add__(self, outro)

# sintaxe Python
y = Y(4)
print y(2)
z = Y(6)
print y + z

# O que realmente está acontecendo
Y.__init__(y, 4)
print Y.__call__(y, 2)
Y.__init__(z, 6)
print Y.__add__(y, z)
                        </code></pre>
                        <p>Vamos aprender mais sobre eles!</p>
                        <h3>Chamando um método especial</h3>
                        <p>Substitua o método <code>valor</code> pelo
                            método especial <code>__call__</code>:</p>
                        <pre><code class="language-python">
class Y:
    def __init__(self, v0):
        self.v0 = v0
        self.g = 9.81

    def __call__(self, t):
        return self.v0*t - 0.5*self.g*t**2
                        </code></pre>
                        <p>Agora podemos escrever:</p>
                        <pre><code class="language-python">
y = Y(3)
v = y(0.1) # o mesmo que v = y.__call__(0.1) ou Y.__call__(y, 0.1)
                        </code></pre>
                        <p>Nota:</p>
                        <ul>
                            <li>A instância <code>y</code> se comporta e parece
                            como uma função;</li>
                            <il>O método <code>valor(t)</code> faz a mesma coisa,
                                mas <code>__call__</code> permite uma sintaxe mais
                            simples e limpa para calcular o valor da função.</il>
                        </ul>
                        <h3>Generalizando a representação de uma função por classes</h3>
                        <p>Dada uma função com \( n+1 \) parâmetros e uma variável
                        independente,</p>
                        $$ f(x; p_0,\ldots,p_n)$$
                        <p>é útil representar <code>f</code> por uma classe onde 
                        \( p_0,\ldots,p_n \) são atributos e <code>__call__(x)</code> 
                        calcula \( f(x) \).</p>
                        <pre><code class="language-python">
class MyFunc:
    def __init__(self, p0, p1, p2, ..., pn):
        self.p0 = p0
        self.p1 = p1
        ...
        self.pn = pn

    def __call__(self, x):
        return ...
                        </code></pre>
                    </div>                                        
                    <div class="bs-docs-section" id="deriv_funcao">
                        <h1 class="page-header">Classe para derivar uma função</h1>

                        <p>Dada certa função matemática em Python, digamos:</p>
                        <pre><code class="language-python">
def f(x):
    return x**3
                        </code></pre>
                        <p>Podemos fazer uma classe <code>Derivada</code> e
                        escrever:</p>
                        <pre><code class="language-python">
dfdx = Derivada(f)
                        </code></pre>
                        <p>Então, <code>dfdx</code> se comporta como uma função
                            que calcula a derivada de <code>f(x)</code>?</p>
                        <pre><code class="language-python">
print dfdx(2)   # calcula 3*x**2 para x=2
                        </code></pre> 
                        <h3>Solução</h3>
                        <p><b>Método</b></p>
                        <p>Vamos usar uma derivação numérica por de trás dos panos:</p>
                        $$ f'(x) \approx {f(x+h)-f(x)\over h} $$
                        <p>para um pequeno \( h \), digamos de \( h=10^{-5} \)</p>
                        <h3>Implementação</h3>
                        <pre><code class="language-python">
class Derivada:
    def __init__(self, f, h=1E-5):
        self.f = f
        self.h = float(h)

    def __call__(self, x):
        f = self.f
        h = self.h
        return (f(x+h) - f(x))/h
                        </code></pre> 
                        <h3>Uso</h3>
                        <pre><code class="language-python">
>>> import math
>>> df = Derivada(math.sin)
>>> x = math.pi
>>> df(x)
-0.9999999999898844
>>> math.cos(x)  # exato
-1.0
>>> def g(t):
...     return t**3
...
>>> dg = Derivada(g)
>>> t = 1
>>> dg(t)  # compare com 3 (exato)
3.000030000110953
                        </code></pre> 
                        <p>Essa é uma implementação útil para o uso em outros métodos
                        que necessitam da derivada, como por exemplo o método de
                        Newton para a solução de equações não lineares.</p>
                        <h3>Função de teste</h3>
                        <ul>
                            <li>Como podemos testar a classe <code>Derivada</code>?</li>
                            <li>Método 1: calcular \( (f(x+h)-f(x))/h \) na mão
                                para algum valor de \( f \) e \( h \);</li>
                            <li>Método 2: utilize funções lineares que resultam
                            em derivadas exatas pela nossa classe, independente
                            de \( h \).</li>
                        </ul>
                        <p>Função de teste baseada no método 2:</p>
                        <pre><code class="language-python">
def test_Derivada():
    # A formula fornece valores exatos para funções lineares, independente de h
    f = lambda x: a*x + b
    a = 3.5
    b = 8
    dfdx = Derivada(f, h=0.5)
    dif = abs(dfdx(4.5) - a)
    assert dif < 1E-14, 'Problema na classe Derivada, dif=%s' % dif
                        </code></pre>
                        <h3>Explicação da função teste</h3>
                        <p>Uso funções <code>lambda</code>:</p>
                        <pre><code class="language-python">
f = lambda x: a*x + b
                        </code></pre>
                        <p>É equivalente a:</p>
                        <pre><code class="language-python">
def f(x):
    return a*x + b
                        </code></pre>
                        <p>Funções <code>lambda</code> são convenientes para produzir
                        códigos rápidos e curtos.</p>
                        <p>Uso de fechamentos:</p>
                        <pre><code class="language-python">
f = lambda x: a*x + b
a = 3.5
b = 8
dfdx = Derivada(f, h=0.5)
dfdx(4.5)
                        </code></pre>
                        <p>Parece claro... mas:</p>
                        <ul>
                            <li>Como <code>Derivada.__call__</code> sabe a e b
                                quando chama nossa função <code>f(x)</code>?</li>
                            <li>Funções locais dentro de funções tem acesso a todas as
                            variáveis locais na função que são definidas!</li>
                            <li><code>f</code> pode acessar a e b em <code>test_Derivada</code>
                                mesmo quando chamada de <code>__call__</code> na
                                classe <code>Derivada</code>;</li>
                            <li><code>f</code> é conhecida como fechamento (closure)
                            na ciência da computação.</li>
                        </ul>
                        <h3>A solução exata mesmo</h3>
                        <p>Podemos também executar a derivação simbólica utilizando
                        o SymPy:</p>
                        <pre><code class="language-python">
>>> import sympy as sp
>>> def g(t):
...     return t**3
...
>>> t = sp.Symbol('t')
>>> dgdt = sp.diff(g(t), t)           # calcula g'(t)
>>> dgdt
3*t**2

>>> # Transformando a expressão sympy dgdt em função python dg(t)
>>> dg = lambdify([t], dgdt)
>>> dg(1)
3
                        </code></pre>
                        <h3>Classe baseada no SymPy</h3>
                        <pre><code class="language-python">
import sympy as sp

class Derivada_sympy:
    def __init__(self, f):
        # f: Python f(x)
        x = sp.Symbol('x')
        sympy_f = f(x)
        sympy_dfdx = sp.diff(sympy_f, x)
        self.__call__ = sp.lambdify([x], sympy_dfdx)
                        </code></pre>
                        <p>Uso:</p>
                        <pre><code class="language-python">
>>> def g(t):
...    return t**3

>>> def h(y):
...    return sp.sin(y)

>>> dg = Derivada_sympy(g)
>>> dh = Derivada_sympy(h)
>>> dg(1)   # 3*1**2 = 3
3
>>> import math
>>> dh(pi)  # cos(math.pi) = -1
-1.0
                        </code></pre>
                    </div>
                    <div class="bs-docs-section" id="classe_integracao">
                        <h1 class="page-header">Classe para Integrar uma função</h1>
                        <div class="text-center">
                            <img width="800" src="./imagens/integral_comic_strip.png" alt="Integrais">
                        </div>

                        <p>Dada a função \( f(x) \), nós queremos calcular</p>
                        $$ F(x; a) = \int_a^x f(t)dt $$
                        
                        <h3>A técnica</h3>
                        <p>Podemos utilizar, por exemplo, a regra dos trapézios:</p>
                        $$
                        \int_a^x f(t)dt = h\left({1\over2}f(a) + \sum_{i=1}^{n-1} f(a+ih) + {1\over2}f(x)\right)
                        $$
                        <p>O objetivo é obter um código que resolva da seguinte forma:</p>
                        <pre><code class="language-python">
def f(x):
    return math.exp(-x**2)*math.sin(10*x)

a = 0
n = 200
F = Integral(f, a, n)
x = 1.2
print F(x)
                        </code></pre>
                        <h3>Implementação</h3>
                        <pre><code class="language-python">
def trapezios(f, a, x, n):
    h = (x-a)/float(n)
    I = 0.5*f(a)
    for i in range(1, n):
        I += f(a + i*h)
    I += 0.5*f(x)
    I *= h
    return I
                        </code></pre>
                        <p>A classe <code>Integral</code> possui <code>f</code>, 
                            <code>a</code> e <code>n</code> como atributos e tem um
                        método especial de chamada para o cálculo da integral:</p>
                        <pre><code class="language-python">
class Integral:
    def __init__(self, f, a, n=100):
        self.f, self.a, self.n = f, a, n

    def __call__(self, x):
        return trapezios(self.f, self.a, x, self.n)
                        </code></pre>
                        <h3>Função de teste</h3>
                        <ul>
                            <li>Como podemos testar a classe <code>integral</code>?</li>
                            <li>Método 1: calcular na mão alguma $f$ para um $n$ pequeno;</li>
                            <li>Método 2: utilizar aquelas funções lineares que 
                            são integradas exatamente pela nossa integração numérica,
                            independente de $n$.</li>
                        </ul>
                        <p>Função de teste baseada no método 2:</p>
                        <pre><code class="language-python">
def test_Integral():
    f = lambda x: 2*x + 5
    F = lambda x: x**2 + 5*x - (a**2 + 5*a)
    a = 2
    dfdx = Integralf, a, n=4)
    x = 6
    dif = abs(I(x) - (F(x) - F(a)))
    assert dif < 1E-15, 'Problema na classe Integral, dif=%s' % dif
                        </code></pre>
                        
                    </div>
                    <div class="bs-docs-section" id="metodo_especial_saida">
                        <h1 class="page-header">Um método especial para a saída</h1>
                        
                        <ul>
                            <li>Em Python, normalmente obtemos uma saída em formato
                                de texto usando o objeto <code>print</code>, que
                            funciona para tipos de objetos já embutidos (strings, listas, floats...);</li>
                            <li>Python não sabe como imprimir objetos de uma classe 
                            definida pelo usuário, mas se a classe definir
                            um método <code>__str__</code>, o Python vai utilizar
                            esse método para converter um objeto em cadeia de caracteres.</li>
                        </ul>

                        <p>Exemplo:</p>
                        <pre><code class="language-python">
class Y:
    ...
    def __call__(self, t):
        return self.v0*t - 0.5*self.g*t**2

    def __str__(self):
        return 'v0*t - 0.5*g*t**2; v0=%g' % self.v0
                        </code></pre>
                        <p>Uso:</p>
                        <pre><code class="language-python">
>>> y = Y(1.5)
>>> y(0.2)
0.1038
>>> print y
v0*t - 0.5*g*t**2; v0=1.5
                        </code></pre>
                    </div>
                    <div class="bs-docs-section" id="classe_polinomiais">
                        <h1 class="page-header">Classe para polinômios</h1>

                        <p>Um polinômio pode ser especificado por uma lista de 
                        seus coeficientes, por exemplo \( 1 - x^2 + 2x^3 \) é</p>
                        $$  1 + 0\cdot x - 1\cdot x^2 + 2\cdot x^3 $$
                        <p>e os coeficientes podem ser armazenados como
                            <code>[1, 0, -1, 2]</code>.</p>
                        <p>Código desejado da aplicação:</p>
                        <pre><code class="language-python">
>>> p1 = Polinomial([1, -1])
>>> print p1
1 - x
>>> p2 = Polinomial([0, 1, 0, 0, -6, -1])
>>> p3 = p1 + p2
>>> print p3.coef
[1, 0, 0, 0, -6, -1]
>>> print p3
1 - 6*x^4 - x^5
>>> p2.derivada()
>>> print p2
1 - 24*x^3 - 5*x^4
                        </code></pre>
                        <p>Como podemos fazer a classe <code>Polinomial</code>?</p>
                        <h3>Código básico</h3>
                        <pre><code class="language-python">
class Polinomial:
    def __init__(self, coeficientes):
        self.coef = coeficientes

    def __call__(self, x):
        s = 0
        for i in range(len(self.coef)):
            s += self.coef[i]*x**i
        return s
                        </code></pre>
                        <h3>Adição</h3>
                        <pre><code class="language-python">
class Polinomial:
    ...

    def __add__(self, outro):
        # return self + outro

        # inicia com a lista mais longa e adiciona a outra:
        if len(self.coef) > len(outro.coef):
            coefsoma = self.coeff[:]  # copia!
            for i in range(len(outro.coef)):
                coefsoma[i] += outro.coef[i]
        else:
            coefsoma = outro.coef[:] # copia!
            for i in range(len(self.coef)):
                coefsoma[i] += self.coef[i]
        return Polinomial(coefsoma)
                        </code></pre>
                        <h3>Multiplicação</h3>
                        <p>Multiplicação genérica de dois polinômios quaisquer:</p>
                        $$ \left(\sum_{i=0}^Mc_ix^i\right)\left(\sum_{j=0}^N d_jx^j\right) = \sum_{i=0}^M \sum_{j=0}^N c_id_j x^{i+j} $$
                        O coeficiente que corresponde a potência \( i+j \) é \( c_i\cdot d_j \). A
                        lista <code>r</code> dos coeficientes do resultado é:
                        <code>r[i+j] = c[i]*d[j]</code> (<code>i</code> e <code>j</code> variando de
                        0 a \( M \) e \( N \), respectivamente.)
                        <p>Implementação</p>
                        <pre><code class="language-python">
class Polinomial:
    ...
    def __mul__(self, outro):
        M = len(self.coef) - 1
        N = len(outro.coef) - 1
        coef = [0]*(M+N+1)  # or zeros(M+N+1)
        for i in range(0, M+1):
            for j in range(0, N+1):
                coef[i+j] += self.coef[i]*outro.coef[j]
        return Polinomial(coef)
                        </code></pre>
                        <h3>Derivada</h3>
                        <p>A regra da derivada de um polinômio genérico da matemática é?</p>
                        $$ {d\over dx}\sum_{i=0}^n c_ix^i = \sum_{i=1}^n ic_ix^{i-1}$$
                        Se <code>c</code> é a lista de coeficientes, a derivada tem uma lista
                        de coeficientes, <code>dc</code>, onde <code>dc[i-1] = i*c[i]</code> para
                        <code>i</code> variando de 1 até o máximo índice em <code>c</code>.
                        Note que <code>dc</code> tem um elemento a menos que <code>c</code>.
                        <p>Implementação:</p>
                        <pre><code class="language-python">
class Polinomial:
    ...
    def derivacao(self):    # muda o self
        for i in range(1, len(self.coef)):
            self.coef[i-1] = i*self.coef[i]
        del self.coef[-1]

    def derivada(self):       # retorna um novo polinômio
        dpdx = Polinomial(self.coef[:])  # copia
        dpdx.derivacao()
        return dpdx
                        </code></pre>
                        <h3>Saída formatada</h3>
                        <pre><code class="language-python">
class Polinomial:
    ...
    def __str__(self):
        s = ''
        for i in range(0, len(self.coef)):
            if self.coef[i] != 0:
                s += ' + %g*x^%d' % (self.coef[i], i)
        # corrigindo os casos especiais:
        s = s.replace('+ -', '- ')
        s = s.replace(' 1*', ' ')
        s = s.replace('x^0', '1')
        s = s.replace('x^1 ', 'x ')
        s = s.replace('x^1', 'x')
        if s[0:3] == ' + ':  # removendo o + inicial
            s = s[3:]
        if s[0:3] == ' - ':  # corrigindo espaços para - inicial
            s = '-' + s[3:]
        return s
                        </code></pre>
                        <h3>Uso</h3>
                        <p>Considere</p>
                        $$ p_1(x)= 1-x,\quad p_2(x)=x - 6x^4 - x^5 $$
                        <p>e sua soma</p>
                        $$ p_3(x) = p_1(x) + p_2(x) = 1 -6x^4 - x^5 $$
                        <pre><code class="language-python">
>>> p1 = Polinomial([1, -1])
>>> print p1
1 - x
>>> p2 = Polinomial([0, 1, 0, 0, -6, -1])
>>> p3 = p1 + p2
>>> print p3.coef
[1, 0, 0, 0, -6, -1]
>>> p2.derivacao()
>>> print p2
1 - 24*x^3 - 5*x^4
                        </code></pre>
                        
                    </div>
                    <div class="bs-docs-section" id="novos_metodos_especiais">
                        <h1 class="page-header">Definição dos métodos especiais</h1>

                        <p>Esté a cargo do programador definir a ação dos métodos
                            especiais. Como deveria <code>__add__(self, outro)</code>
                        ser definido? Isso depende completamente do programador,
                        dependendo do significado de <code>objeto1 + objeto2</code>.</p>
                        <blockquote>
Um antropoligista estava perguntando a um homem das cavernas primitivo sobre aritmética.
Quando o antropologista perguntava, O que dois e dois fazem? o homem das cavernas respondia, cinco.
Perguntado para explicar, o homem das cavernas disse, se eu tenho uma corda com dois nós,
e outra corda com dois nós, e eu unir as duas cordas para fazer uma, então eu tenho cinco nós.
                        </blockquote>
                        <h3>Métodos especiais para operações aritméticas</h3>
                        <pre><code class="language-python">
c = a + b    #  c = a.__add__(b)

c = a - b    #  c = a.__sub__(b)

c = a*b      #  c = a.__mul__(b)

c = a/b      #  c = a.__div__(b)

c = a**e     #  c = a.__pow__(e)
                        </code></pre>
                        <h3>Métodos especiais para comparação</h3>
                        <pre><code class="language-python">
a == b       #  a.__eq__(b)

a != b       #  a.__ne__(b)

a < b        #  a.__lt__(b)

a <= b       #  a.__le__(b)

a > b        #  a.__gt__(b)

a >= b       #  a.__ge__(b)
                        </code></pre>
                        
                    </div>
                    <div class="bs-docs-section" id="classe_vetores_plano">
                        <h1 class="page-header">Classe para vetores no plano</h1>

                        <p>Operações matemáticas para vetores no plano:</p>
                        $$
                        \begin{align*}
                        (a,b) + (c,d) &= (a+c, b+d)\\
                        (a,b) - (c,d) &= (a-c, b-d)\\
                        (a,b)\cdot(c,d) &= ac + bd\\
                        (a,b) &= (c, d)\hbox{ if }a=c\hbox{ and }b=d
                        \end{align*}
                        $$
                        <p>Código de aplicação desejado:</p>
                        <pre><code class="language-python">
>>> u = Vet2D(0,1)
>>> v = Vet2D(1,0)
>>> print u + v
(1, 1)
>>> a = u + v
>>> w = Vet2D(1,1)
>>> a == w
True
>>> print u - v
(-1, 1)
>>> print u*v
0
                        </code></pre>
                        <h3>Implementação</h3>
                        <pre><code class="language-python">
class Vey2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, outro):
        return Vet2D(self.x+outro.x, self.y+outro.y)

    def __sub__(self, outro):
        return Vet2D(self.x-outro.x, self.y-outro.y)

    def __mul__(self, outro):
        return self.x*outro.x + self.y*outro.y

    def __abs__(self):
        return math.sqrt(self.x**2 + self.y**2)

    def __eq__(self, outro):
        return self.x == outro.x and self.y == outro.y

    def __str__(self):
        return '(%g, %g)' % (self.x, self.y)

    def __ne__(self, outro):
        return not self.__eq__(outro)  # reusando __eq__
                        </code></pre>
                    </div>
                    <div class="bs-docs-section" id="metodo_especial_repr">
                        <h1 class="page-header">O método especial <code>__repr__</code></h1>

                        <p>O método especial <code>__repr__</code> cria <code>p</code>
                            de <code>eval(repr(p))</code></p>
                        <pre><code class="language-python">
class MinhaClasse:
    def __init__(self, a, b):
        self.a, self.b = a, b

    def __str__(self):
        """Retorna uma cadeia de caracteres formatada com a saída"""
        return 'a=%s, b=%s' % (self.a, self.b)

    def __repr__(self):
        """Retorna uma cadeia de caracteres tal que eval(s) cria self."""
        return 'MinhaClasse(%s, %s)' % (self.a, self.b)
                        </code></pre>
                        <p>Uso</p>
                        <pre><code class="language-python">
>>> m = MinhaClasse(1, 5)
>>> print m      # chama m.__str__()
a=1, b=5
>>> str(m)       # chama m.__str__()
'a=1, b=5'
>>> s = repr(m)  # chama m.__repr__()
>>> s
'MinhaClasse(1, 5)'
>>> m2 = eval(s) # o mesmo que m2 = MinhaClasse(1, 5)
>>> m2           # chama m.__repr__()
'MinhaClasse(1, 5)'
                        </code></pre>
                    </div>
                    <div class="bs-docs-section" id="revendo_classe_Y">
                        <h1 class="page-header">Classe Y reescrita com
                            o método <code>repr</code></h1>

                        <pre><code class="language-python">
class Y:
    """Classe para a função y(t; v0, g) = v0*t - 0.5*g*t**2."""

    def __init__(self, v0):
        """Armazenando parâmetros."""
        self.v0 = v0
        self.g = 9.81

    def __call__(self, t):
        """Avaliando a função."""
        return self.v0*t - 0.5*self.g*t**2

    def __str__(self):
        """Saída formatada."""
        return 'v0*t - 0.5*g*t**2; v0=%g' % self.v0

    def __repr__(self):
        """Mostre o código para gerar essa instância."""
        return 'Y(%s)' % self.v0
                        </code></pre>
                        
                    </div>
                    <div class="bs-docs-section" id="classe_num_complexo">
                        <h1 class="page-header">Classe para números complexos</h1>

                        <p>O Python já possui a classe <code>complex</code> para
                        números complexos, mas implementar tal classe é um 
                        bom exemplo pedagógico especialmente com métodos especiais.</p>
                        <p>Uso esperado:</p>
                        <pre><code class="language-python">
>>> u = Complexo(2,-1)
>>> v = Complexo(1)     # parte imaginária zero
>>> w = u + v
>>> print w
(3, -1)
>>> w != u
True
>>> u*v
Complexo(2, -1)
>>> u < v
illegal operation "<" for complex numbers
>>> print w + 4
(7, -1)
>>> print 4 - w
(1, 1)
                        </code></pre>
                        <h3>Implementação</h3>
                        <pre><code class="language-python">
class Complexo:
    def __init__(self, real, imag=0.0):
        self.real = real
        self.imag = imag

    def __add__(self, outro):
        return Complexo(self.real + outro.real,
                       self.imag + outro.imag)

    def __sub__(self, outro):
        return Complexo(self.real - outro.real,
                       self.imag - outro.imag)

    def __mul__(self, outro):
        return Complexo(self.real*outro.real - self.imag*outro.imag,
                       self.imag*outro.real + self.real*outro.imag)

    def __div__(self, outro):
        ar, ai, br, bi = self.real, self.imag, \
                         outro.real, outro.imag # forma curta
        r = float(br**2 + bi**2)
        return Complexo((ar*br+ai*bi)/r, (ai*br-ar*bi)/r)
                        </code></pre>
                        <h3>Métodos adicionais</h3>
                        <pre><code class="language-python">
    def __abs__(self):
        return sqrt(self.real**2 + self.imag**2)

    def __neg__(self):   # defines -c (c is Complexo)
        return Complexo(-self.real, -self.imag)

    def __eq__(self, outro):
        return self.real == outro.real and \
               self.imag == outro.imag

    def __ne__(self, outro):
        return not self.__eq__(outro)

    def __str__(self):
        return '(%g, %g)' % (self.real, self.imag)

    def __repr__(self):
        return 'Complexo' + str(self)

    def __pow__(self, potencia):
        raise NotImplementedError(
          'self**potencia ainda não implementado para Complexo')
                        </code></pre>
                        <h3>Refinando os métodos especiais para aritmética</h3>
                        <p>Podemos adicionar um número real a um número complexo?</p>
                        <pre><code class="language-python">
>>> u = Complexo(1, 2)
>>> w = u + 4.5
...
AttributeError: 'float' object has no attribute 'real'
                        </code></pre>
                        <p>Problema: vamos assumir que o <code>outro</code> é
                            <code>Complexo</code>. Solução:</p>
                        <pre><code class="language-python">
class Complexo:
    ...
    def __add__(self, outro):
        if isinstance(outro, (float,int)):
            outro = Complexo(outro)
        return Complexo(self.real + outro.real,
                       self.imag + outro.imag)

# ou

    def __add__(self, outro):
        if isinstance(outro, (float,int)):
            return Complexo(self.real + outro, self.imag)
        else:
            return Complexo(self.real + outro.real,
                           self.imag + outro.imag)
                        </code></pre>
                        <h3>Métodos especiais para adição</h3>
                        <p>E se tentarmos:</p>
                        <pre><code class="language-python">
>>> u = Complexo(1, 2)
>>> w = 4.5 + u
...
TypeError: unsupported operand type(s) for +:
    'float' and 'instance'
                        </code></pre>
                        <p>Problema: o objeto <code>float</code> do Python não
                            pode ser adicionado a um objeto <code>Complexo</code>.</p>
                        <p>Solução: se a classe tem o método especial <code>__radd__(self, other)</code>,
                            Python o aplica para <code>outro + self</code>.</p>
                        <pre><code class="language-python">
class Complexo:
    ...
    def __radd__(self, other):
        """Retorna outro + self."""
        # outro + self = self + outro:
        return self.__add__(outro)
                        </code></pre>
                        <h3>Métodos especiais para subtração</h3>
                        <p>Operadores para subtração são um pouco mais complicados
                        pois \( a-b \neq b-a \)</p>
                        <pre><code class="language-python">
class Complexo:
    ...
    def __sub__(self, outro):
        if isinstance(outro, (float,int)):
            outro = Complexo(outro)
        return Complexo(self.real - outro.real,
                       self.imag - outro.imag)

    def __rsub__(self, outro):
        if isinstance(outro, (float,int)):
            outro = Complexo(outro)
        return outro.__sub__(self)
                        </code></pre>
                    </div>
                    <div class="bs-docs-section" id="dentro_classe">
                        <h1 class="page-header">O que tem em uma classe?</h1>
                        <pre><code class="language-python">
class A:
    """Uma classe para demonstração."""
    def __init__(self, valor):
        self.v = valor
                        </code></pre>

                        <p>Qualquer instância mantém seus atributos em um dicionário 
                            criado automaticamente pelo Python<code>self.__dict__ dictionary</code>.</p>
                        <pre><code class="language-python">
>>> a = A([1,2])
>>> print a.__dict__  # todos os atributos
{'v': [1, 2]}
>>> dir(a)            # o que tem no objeto a?
'__doc__', '__init__', '__module__', 'dump', 'v']
>>> a.__doc__         # documentação de A
'Uma classe para demonstração.'
                        </code></pre>
                        
                    </div>
                    <div class="bs-docs-section" id="adicionar_atributos">
                        <h1 class="page-header">Podemos adicionais quantos novos
                        atributos quisermos!</h1>

                        <pre><code class="language-python">
>>> a.minha_var = 10            # add new attribute (!)
>>> a.__dict__
{'minha_var': 10, 'v': [1, 2]}
>>> dir(a)
['__doc__', '__init__', '__module__', 'dump', 'minha_var', 'v']

>>> b = A(-1)
>>> b.__dict__              # b não tem atributo minha_var
{'v': -1}
>>> dir(b)
['__doc__', '__init__', '__module__', 'dump', 'v']
                        </code></pre>
                        
                    </div>
                    <div class="bs-docs-section" id="resumo_classes">
                        <h1 class="page-header">Resumo de classes</h1>
                        <h3>Definindo a classe</h3>
                        <p>Exemplo sobre a definição de uma classe com atributos e
                        métodos</p>
                        <pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt

class Gravidade:
    """Força da Gravidade entre dois objetos."""
    def __init__(self, m, M):
        self.m = m
        self.M = M
        self.G = 6.67428E-11 # Constante de gravitação

    def forca(self, r):
        G, m, M = self.G, self.m, self.M
        return G*m*M/r**2

    def visualizacao(self, r_start, r_stop, n=100):
        r = np.linspace(r_start, r_stop, n)
        g = self.forca(r)
        plt.title('m=%g, M=%g' % (self.m, self.M))
        plt.plot(r, g)
        plt.show()
                        </code></pre>
                        <h3>Exemplo de uso dessa classe</h3>
                        <pre><code class="language-python">
mass_lua = 7.35E+22
mass_terra = 5.97E+24

# criando a instância (objeto) da classe Gravidade:
gravidade = Gravidade(mass_lua, mass_terra)

r = 3.85E+8  # distância da lua à terra em metros
Fg = gravity.force(r)   # chamando o método força da classe
gravidade.visualizacao(0, 100) # visualizando
                        </code></pre>
                        <h3>Resumos dos métodos especiais</h3>
                        <ul>
                            <li> <code>c = a + b</code> implica <code>c = a.__add__(b)</code></li>
                            <li> Existem métodos especiais para <code>a+b</code>, 
                                <code>a-b</code>, <code>a*b</code>, <code>a/b</code>, 
                                <code>a**b</code>, <code>-a</code>, <code>if a:</code>, 
                                <code>len(a)</code>, <code>str(a)</code> (saída formatada),
                                <code>repr(a)</code> (recria <code>a</code> com <code>eval</code>), etc.</li>
                            <li> Com os métodos especiais podemos criar novos objetos
                                matemáticos como vetores, polinoniais, números complexos e
                                escrever "codigos matemáticos" (aritmética)</li>
                            <li> A chamada dos métodos especiais é particularmente
                                útil: <code>v = c(5)</code> significa <code>v = c.__call__(5)</code></li>
                            <li> Funções com parâmetros devem ser representadas por uma
                            classe com os parâmetros como atributos e com uma chamada a
                            um método especial para a avaliação da função.</li>
                        </ul>
                        
                    </div>
                    
                    <div class="bs-docs-section" id="final">
                        <h1 class="page-header">Tarefa</h1>
                        <p>
                            <b>Quantificação da incerteza:</b>
                        </p>                        
                        <p>Considere a medição da gravidade $g$ através da queda 
                        de uma bola de \( y=y_0 \) para \( y=0 \) no tempo \( T \):</p>
                        $$ g = 2y_0T^{-2} $$
                        <p>E se \( y_0 \) e \( T \) são incertos? Digamos \( y_0\in [0.99,1.01] \) m
                        e \( T\in [0.43, 0.47] \) s. Qual é o grau de incerteza em \( g \)?</p>

                        <p>Regras para calcular com intervalos, \( p=[a,b] \) e \( q=[c,d] \):</p>
                        <ul>
                            <li> \( p+q = [a + c, b + d] \)</li>
                            <li> \( p-q = [a - d, b - c] \)</li>
                            <li> \( pq =  [\min(ac, ad, bc, bd), \max(ac, ad, bc, bd)] \)</li>
                            <li> \( p/q = [\min(a/c, a/d, b/c, b/d), \max(a/c, a/d, b/c, b/d)] \)
                                (\( [c,d] \) não pode conter zero)</li>
                        </ul>
                        <p>Objetivo: fazer uma classe para a aritmética com intervalos.</p>

                        <!--SOLUÇÃO DA TAREFA-->
                        <button type="button" class="btn btn-info disabled">Solução</button>                        
                        <!--<button type="button" class="btn btn-info" data-toggle="collapse" data-target="#tarefa">Solução</button>-->
                        <!--Final solução da tarefa-->                        

                        <div id="tarefa" class="collapse">
                            <h3> Exemplo de solução: </h3>

                            <pre><code class="language-python">
class IntervalosCalc:
    def __init__(self, lower, upper):
        self.lo = float(lower)
        self.up = float(upper)

    def __add__(self, outro):
        a, b, c, d = self.lo, self.up, outro.lo, outro.up
        return IntervalosCalc(a + c, b + d)

    def __sub__(self, outro):
        a, b, c, d = self.lo, self.up, outro.lo, outro.up
        return IntervalosCalc(a - d, b - c)

    def __mul__(self, outro):
        if isinstance(outro, (int, float)):      
            outro = IntervalMath(outro, outro)   
        a, b, c, d = self.lo, self.up, outro.lo, outro.up
        return IntervalosCalc(min(a*c, a*d, b*c, b*d),
                            max(a*c, a*d, b*c, b*d))

    def __rmul__(self, outro):
        if isinstance(outro, (int, float)):
            outro = IntervalosCalc(outro, outro)
        return outro*self

    def __pow__(self, expoente):
        if isinstance(expoente, int):
            p = 1
            if expoente > 0:
                for i in range(expoente):
                    p = p*self
            elif expoente < 0:
                for i in range(-expoente):
                    p = p*self
                p = 1/p
            else:   # expoente == 0
                p = IntervalosCalc(1, 1)
            return p
        else:
            raise TypeError('expoente deve ser inteiro')

    def __div__(self, outro):
        a, b, c, d = self.lo, self.up, outro.lo, outro.up
        if c*d <= 0: return None
        return IntervalosCalc(min(a/c, a/d, b/c, b/d),
                            max(a/c, a/d, b/c, b/d))
    def __float__(self): # arredondando o valor no ponto métio
        return 0.5*(self.lo + self.up)

    def __str__(self):
        return '[%g, %g]' % (self.lo, self.up)

    def __repr__(self):
        return '%s(%g, %g)' % \
          (self.__class__.__name__, self.lo, self.up)
                            </code></pre>
                            <p>Demonstração de uso:</p>
                            <pre><code class="language-python">
I = IntervalosCalc   # abreviado
a = I(-3,-2)
b = I(4,5)

expr = 'a+b', 'a-b', 'a*b', 'a/b'   # expressões teste
for e in expr:
    print e, '=', eval(e)
                            </code></pre>
                            <p>Uso aplicado a \( g=2y_0T^{-2} \)</p>
                            <pre><code class="language-python">
>>> g = 9.81
>>> y_0 = I(0.99, 1.01)
>>> Tm = 0.45                 # valor médio de T
>>> T = I(Tm*0.95, Tm*1.05)   # 10% de incerteza
>>> print T
[0.4275, 0.4725]
>>> g = 2*y_0*T**(-2)
>>> g
IntervalosCalc(8.86873, 11.053)
>>> # calculando com valores médios:
>>> T = float(T)
>>> y = 1
>>> g = 2*y_0*T**(-2)
>>> print '%.2f' % g
9.88
                            </code></pre>
                        </div>

                    </div>
                    
                </div>
                <!-- FINAL Conteúdo Principal -->
                
                <!-- Menu lateral -->
                <div class="col-md-3" role="complementary"> 
                    <nav class="bs-docs-sidebar hidden-print hidden-sm hidden-xs affix-top" id="menuLateral"> 
                        <ul class="nav bs-docs-sidenav"> 
                            <li><a href="#inicio">Introdução a Classes</a></li>
                        </ul> 
                        <a href="#top" class="back-to-top"> Voltar ao topo </a>                 
                    </nav> 
                </div>
                <!-- FINAL Menu lateral -->
                
            </div>
        </div>
        <!-- FINALParte principal -->
        
        <!-- Rodapé -->
        <footer class="bs-docs-footer"> 
            <div class="container"> 
                <ul class="bs-docs-footer-links"> 
                    <li><a href="http://www.estruturas.ufpr.br" target="_blank">estruturas.UFPR</a></li> 
                    <li><a href="http://www.estruturas.ufpr.br/disciplinas/pos-graduacao/introducao-a-computacao-cientifica-com-python/" target="_blank">Introdução à computação científica</a></li> 
                    <li><a href="https://www.python.org/" target="_blank">Python.org</a></li> 
                    <li><a href="https://www.python.org/dev/peps/pep-0257/" target="_blank">Docstring Conventions</a></li> 
                </ul> 
                <p>
                    Prof. Marco André Argenta
                </p> 
            </div> 
        </footer>
        <!-- FINAL Rodapé -->        
        
        <script src="../adicionais/jquery.min.js"></script>
        <script src="../adicionais/bootstrap.min.js"></script>
        <script src="./js/docs.min.js"></script>
        <script src="./js/prism.js"></script>
    </body>
</html>
