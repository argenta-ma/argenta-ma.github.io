<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">  
        <meta content="IE=edge" http-equiv="X-UA-Compatible"> 
        <meta content="width=device-width,initial-scale=1" name="viewport"> 
        <meta content="Aulas de introcução à computação científica." name="description"> 
        <meta content="Markinho" name="author"> 
        
        <title> Arranjos e gráficos de curvas </title> 
        
        <link href="./css/bootstrap.min.css" rel="stylesheet">        
        <link href="./css/docs.min.css" rel="stylesheet">
        <link href="./css/carbonads.css" rel="stylesheet">
        <link href="./css/prism.css" rel="stylesheet">
        
        <link href="../imagens/favicon.ico" rel="icon"> 
        
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
        </script>
        <script type="text/javascript" async
            src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
        </script>
        
    </head>
    <body>
        
        <!-- Cabeçalho -->
        <div class="v4-tease">
            <a href="http://www.estruturas.ufpr.br">
                <img style="position: absolute; top: 0; left: 0; border: 0;" 
                     src="../imagens/estruturasUFPR.png" alt="Voltar para Estruturas.UFPR">
            </a>
            <a class="navbar-brand" style="position: absolute; left: 360px;" href="../index.html">
                Aulas de Introdução a Computação Científica
            </a>
        </div>
         <!-- FINAL Cabeçalho -->
        
        <!-- Menu superior -->
        <header class="bs-docs-nav navbar navbar-static-top" id="top"> 
            <div class="container"> 
                <div class="navbar-header"> 
                    <button aria-controls="bs-navbar"  
                            class="collapsed navbar-toggle" data-target="#bs-navbar" 
                            data-toggle="collapse" type="button"> 
                        <span class="sr-only">Alternar Navegação</span> 
                        <span class="icon-bar"></span> 
                        <span class="icon-bar"></span> 
                        <span class="icon-bar"></span> 
                    </button>
                </div> 
                <nav class="collapse navbar-collapse" id="bs-navbar"> 
                    <ul class="nav navbar-nav"> 
                        <li class="active"> <a href="lacoslistas.html">Arranjos e gráficos de curvas</a> </li>
                        <li><a href="#final">Tarefa</a></li>
                    </ul> 
                    <ul class="nav navbar-nav navbar-right"> 
                        <li class="dropdown" id="accountmenu">
                            <a class="dropdown-toggle" data-toggle="dropdown" href="#">Demais tópicos abordados<b class="caret"></b></a>
                            <ul class="dropdown-menu">
                                <li><a href="../index.html#___sec0">Programando equações</a></li>
                                <li><a href="../index.html#___sec1">Laços e listas</a></li>
                                <li><a href="../index.html#___sec2">Funções e ramificações</a></li>
                                <li><a href="../index.html#___sec3">Entrada do usuário e manipulação de erros</a></li>
                                <li><a href="../index.html#___sec4">Arranjos e gráficos de curvas</a></li>            
                                <li><a href="../index.html#___sec6">Dicionários e cadeias de caracteres</a></li>
                                <li><a href="../index.html#___sec7">Introdução a Classes</a></li>            
                                <li><a href="../index.html#___sec9">Programação orientada a objeto</a></li>
                                <li><a href="../index.html#___sec10">Números aleatórios e jogos simples</a></li>
                                <li><a href="../index.html#___secA">Sequências e relações de recorrência</a></li>
                                <li><a href="../index.html#___secB">Programação de equações diferenciais</a></li>
                                <li><a href="../index.html#___secC">Gráficos tridimensionais</a></li>
                                <li><a href="../index.html#___secD">Programação em paralelo</a></li>
                                <li><a href="../index.html#___secE">Interfaces gráficas de usuário (GUI)</a></li>
                                <li><a href="../index.html#___secF">Migrando Python para código compilado</a></li> 
                            </ul>
                        </li> 
                    </ul> 
                </nav> 
            </div> 
        </header>
        <!-- FINAL MENU SUPERIOR -->
        
        <!-- Painel Superior -->
        <div class="bs-docs-header" id="content" tabindex="-1"> 
            <div class="container"> 
                <h1>Arranjos e gráficos de curvas</h1> 
                <p>São muitos os dados: use arranjos e grafique para melhor visualizar!<br>
                <font size="2px">Prof. Marco André Argenta / PPGECC / UFPR</font></p>
                <div id="carbonads-container">
                    <div class="carbonad">
                        <div id="azcarbon">
                            <a href="./imagens/programando_equacoes.png" target="_blank">
                                <!-- Imagens em 120 px altura e 300 px largura -->
                                <img src="./imagens/arranjosgraficos.png" class="carbonad-image carbonad-img">
                            </a>
                        </div>
                    </div>
                </div> 
            </div> 
        </div>
        <!-- FINAL PAINEL SUPERIOR -->
        
        <!-- Parte principal -->
        <div class="container bs-docs-container">
            <div class="row">
                
                <!-- Conteúdo Principal -->
                <div class="col-md-9" role="main">
                    <div class="bs-docs-section"> 
                        <h1 class="page-header" id="inicio">Arranjos e gráficos de curvas</h1> 
                        <div class="well">
                            Um objeto lista é útil para o armazenamento de dados, como uma
                            sequência de objetos ou uma tabela de objetos. Um arranjo (no
                            inglês array) é
                            similar a uma lista, mas menos flexível e muito mais eficiente
                            computacionalmente. Quando usa-se um computador para a execução
                            de operações matemáticas usualmente termina-se com um monte de números
                            e operações matemáticas associadas. Armazenar números em uma lista
                            em tal contexto pode levar a programas lentos, enquanto com "arrays"
                            pode-se ter um programa mais rápido. Isso se torna crucial quando
                            aplicações avançadas demandam horas, dias, inclusive semanas
                            para terminar de processar um programa. Qualquer idéia inteligente
                            que reduza o tempo de execução é primordial.
                        </div>               
                    </div>
                    <div class="bs-docs-section" id="objetivos_graficos">
                        <h1 class="page-header">Vamos aprender a visualizar
                        funções como:</h1>

                        <div class="text-center">
                            <img width="700" src="./imagens/cosseno7.png" alt="Gráfico com indicações">
                        </div>
                        
                        <p>Como escrever programas para produzir tais gráficos?</p>
                        
                    </div>
                    <div class="bs-docs-section" id="arranjos">
                        <h1 class="page-header">Precisamos primeiro aprender sobre
                        um novo objeto, os arranjos (array)</h1>

                        <ul>
                            <li>Curvas $y=f(x)$ são visualizadas através do desenho
                            de linhas retas entre pontos ao longo de uma curva;</li>
                            <li>As coordenadas desses pontos precisam ser armazenadas;</li>
                            <li>Podemos usar listas ou os arranjos;</li>
                            <li>Os arranjos são como as listas, mas mais eficientes
                            computacionalmente;</li>
                            <li>Os arranjos fazem muito mais que ajudar no gráfico
                            de curvas!</li>
                        </ul>                        
                    </div>
                    <div class="bs-docs-section" id="vetores">
                        <h1 class="page-header">O que precisamos saber sobre
                        arranjos</h1>

                        <ul>                            
                            <li>Em geral, arranjos unidimensionais podem representar
                                um vetor $v=(v_0, ..., v_{n-1});</li>
                            <li>Arranjos também podem ser multidimensionais, 
                            podemos representar com eles matrizes e tensores.</li>
                        </ul>
                        
                        $$
                        \left\lbrack\begin{array}{cccc}
                        0 & 12 & -1 & 5\\
                        -1 & -1 & -1 & 0\\
                        11 & 5 & 5 & -2
                        \end{array}\right\rbrack
                        \hspace{1cm}
                        A =
                        \left\lbrack\begin{array}{ccc}
                        A_{0,0} & \cdots &  A_{0,n-1}\\
                        \vdots & \ddots &  \vdots\\
                        A_{m-1,0} & \cdots & A_{m-1,n-1}
                        \end{array}\right\rbrack
                        $$
                        
                        <p>Arranjos (arrays) estão disponíveis em Python através
                        do pacote NumPy (Numerical Python).</p>
                        
                    </div>
                    <div class="bs-docs-section" id="armazenando_coordenadas">
                        <h1 class="page-header">Armazenando pontos $(x,y)$ sobre
                        uma curva em arranjos</h1>

                        <p>Coletando os pontos de uma função $y=f(x)$:</p>
                        <pre><code class="language-python">
>>> import numpy as np
>>> n = 5                     # número de pontos
>>> x = np.linspace(0, 1, n) # n pontos em [0, 1]
>>> y = np.zeros(n)          # n zeros (em float)
>>> for i in xrange(n):
...     y[i] = f(x[i])
...
                        </code></pre>
                        <p>Notas:</p>
                        <ul>
                            <li><code>xrange</code> é com o <code>range</code>
                            mas mais veloz, pois em valores de n grandes, ele
                            não gera uma lista de inteiros, mas permite correr
                            sobre os valores diretamente;</li>
                            <li>Arranjos são sempre criados por funções <code>numpy</code>.</li>
                        </ul>
                        
                    </div>
                    <div class="bs-docs-section" id="eficiencia_arranjos">
                        <h1 class="page-header">Arranjos não são flexíveis como 
                        as listas, mas muito mais eficientes computacionalmente</h1>

                        <ul>
                            <li>Elementos da lista podem ser qualquer objeto Python;</li>
                            <li>Elementos dos arranjos devem ser de apenas um único tipo;</li>
                            <li>Os arranjos são muito eficientes no armazenamento na 
                                memória e no cálculo se os elementos forem <code>int</code>,
                            <code>float</code> ou <code>complex</code>;</li>
                            <li>Dica: use arranjos para sequencias de números!</li>
                        </ul>
                        
                    </div>
                    <div class="bs-docs-section" id="arrays_inteiras">
                        <h1 class="page-header">Podemos trabalhar com arranjos
                        inteiros de uma só vez</h1>

                        <p>Podemos manipular arranjos inteiros ao invés de
                        manipular um elemento por vez.</p>
                        <p>Calcule o seno de um arranjo:</p>
                        <pre><code class="language-python">
from math import sin

for i in xrange(len(x)):
    y[i] = sin(x[i])
                        </code></pre>
                        <p>No entanto, se <code>x</code> for um arranjo,
                            <code>y</code> pode ser calculado por:</p>
                        <pre><code class="language-python">
from math import sin

y = np.sin(x)
                        </code></pre>
                        <p>O laço está agora dentro no <code>np.sin</code> e é
                        implementado em um código muito eficiente em linguagem C.</p>
                        
                    </div>
                    <div class="bs-docs-section" id="operando_arranjos_unica">
                        <h1 class="page-header">Operar sobre arranjos inteiros
                        é chamado de vetorização</h1>

                        <p>Temos com a vetorização:</p>
                        <ul>
                            <li>Código curtos, mais legíveis e mais próximos
                            da matemática;</li>
                            <li>Códigos bem mais rápidos!</li>
                        </ul>
                        <p>Vamos usar o <code>%timeit</code> no console IPython
                        para medir o ganho de desempenho para $y = sen xe^{-x}$:</p>
                        <pre><code class="language-python">
In [1]: n = 100000

In [2]: import numpy as np

In [3]: x = np.linspace(0, 2*np.pi, n+1)

In [4]: y = np.zeros(len(x))

In [5]: %timeit for i in xrange(len(x)): y[i] = np.sin(x[i])*np.exp(-x[i])
1 loops, best of 3: 247 ms per loop

In [6]: %timeit y = np.sin(x)*np.exp(-x)
100 loops, best of 3: 4.77 ms per loop

In [7]: 247/4.77
Out[7]: 51.781970649895186  # vetorização: 50x mais rápida!
                        </code></pre>
                        
                    </div>
                    <div class="bs-docs-section" id="arranjos_e_funcoes">
                        <h1 class="page-header">Uma função $f(x)$ escrita para 
                        um número $x$ normalmente funciona para um arranjo
                        também</h1>

                        <pre><code class="language-python">
from numpy import sin, exp, linspace

def f(x):
    return x**3 + sin(x)*exp(-3*x)

x = 1.2                     # objeto float
y = f(x)                    # y é float

x = linspace(0, 3, 10001)   # 10000 intervalos em [0,3]
y = f(x)                    # y é um arranjo
                        </code></pre>
                        
                        <p>Nota: <code>math</code> é para números e 
                            <code>numpy</code> é para arranjos (arrays)</p>
                        <pre><code class="language-python">
>>> import math, numpy
>>> x = numpy.linspace(0, 1, 11)
>>> math.sin(x[3])
0.2955202066613396
>>> math.sin(x)
...
TypeError: only length-1 arrays can be converted to Python scalars
>>> numpy.sin(x)
array([ 0.     ,  0.09983,  0.19866,  0.29552,  0.38941,
        0.47942,  0.56464,  0.64421,  0.71735,  0.78332,
        0.84147])
                        </code></pre>
                    </div>
                    <div class="bs-docs-section" id="aritmetica_arrajos">
                        <h1 class="page-header">A aritmética de arranjos</h1>

                        <p>A aritmética dos arranjos é uma série de operações
                        binárias, por isso é rápida.</p>
                        <ul>
                            <li> Considere <code>y = f(x)</code>, onde 
                                <code>f</code> retorna <code>x**3 + sin(x)*exp(-3*x)</code></li>
                            <li> <code>f(x)</code> leva ao seguinte conjunto
                                de sub-cálculos vetorizados:
                            <ol>
                                <li> <code>r1 = x**3</code> <br />
                                    <code>for i in range(len(x)): r1[i] = x[i]**3</code> <br />
                                    (mas com laço em C)</li>
                                <li> <code>r2 = sin(x)</code> (calculados elemento
                                    a elemento em C)</li>
                                <li> <code>r3 = -3*x</code></li>
                                <li> <code>r4 = exp(r3)</code></li>
                                <li> <code>r5 = r3*r4</code></li>
                                <li> <code>r6 = r1 + r5</code></li>
                                <li> <code>y = r6</code></li>
                            </ol>
                            </li>
                            <li> Nota: isso é o mesmo conjunto de operações
                                que você faria com uma calculadora quando 
                                <code>x</code> é um número</li>
                        </ul>
                        
                    </div>
                    <div class="bs-docs-section" id="aplicação_arranjo_importante">
                        <h1 class="page-header">Código vetorizado para cálculo
                        de pontos sobre uma curva</h1>

                        $$ f(x) = x^2e^{-\frac{1}{2}x}\sin(x-\frac{1}{3}\pi),\quad x\in [0, 4\pi]$$
                        
                        <p>Cálculo vetorizado de $n+1$ pontos sobre uma curva:</p>
                        <pre><code class="language-python">
import numpy as np

n = 100
x = np.linspace(0, 4*np.pi, n+1)
y = 2.5 + x**2*np.exp(-0.5*x)*np.sin(x-np.pi/3)
                        </code></pre>
                    </div>
                    <div class="bs-docs-section" id="vetorizacao">
                        <h1 class="page-header">Novo termo: vetorização</h1>

                        <ul>
                            <li>Escalar: um número;</li>
                            <li>Arranjo (array): sequência de números;</li>
                            <li>Cálculos escalares atuam em um número por vez,
                            equanto que cálculos vetorizados atuam em arranjos
                            inteiros por vez (sem laços em Python).</li>
                        </ul>
                        <ul>
                            <li>Funções vetorizadas podem operar arranjos;</li>
                            <li>Vetorização é o processo de conversão de um 
                            código em Python com laços em uma versão vetorizada
                            sem laços em Python;</li>
                            <li>Funções matemáticas em Python sem testes <code>if</code>
                            automaticamente trabalham com argumentos de escalares 
                            e arranjos, sem a necessidade de um processo de vetorização.</li>
                        </ul>
                        
                    </div>
                    <div class="bs-docs-section" id="grafico_curva_funcao">
                        <h1 class="page-header">Gráfico de uma função: o básico</h1>

                        <p>Faça o gráfico da curva \( y(t) = t^2e^{-t^2} \):</p>
                        <pre><code class="language-python">
import numpy as np  # importando numpy
import matplotlib.pyplot as plt# importanto o matplotlib para a geração dos gráficos

# fazendo os pontos da curva
t = np.linspace(0, 3, 51)      # 50 intervalos em [0, 3]
y = t**2*np.exp(-t**2)         # expressão vetorizada

plt.plot(t, y)           # faça o gráfico em uma janela
plt.savefig('fig.pdf')   # salvando imagem em PDF
plt.savefig('fig.png')   # salvando imagem em PNG
                        </code></pre>
                    </div>
                    <div class="bs-docs-section" id="grafico_curva_funcao2">
                        <h1 class="page-header">Um gráfico deve conter legenda,
                        rótulo nos eixos e título</h1>

                        <pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt

def f(t):
    return t**2*np.exp(-t**2)

t = np.linspace(0, 3, 51)    # coordenadas em t
y = f(t)                  # valores correspondentes em y

plt.plot(t, y, label=r'$t^2 exp(-t^2)$')           # faça o gráfico em uma janela

plt.xlabel('t')               # rótulo do eixo x
plt.ylabel('y')               # rótulo do eixo y
plt.legend()   # gera a legenda
plt.axis([0, 3, -0.05, 0.6])  # limites [tmin, tmax, ymin, ymax]
plt.title(u'Meu primeiro gráfico completo')
                        </code></pre>
                        
                    </div>
                    <div class="bs-docs-section" id="grafico_varias_curvas">
                        <h1 class="page-header">Gráfico com várias curvas</h1>

                        <p>Como colocar as curvas de \( cos(\theta) \) e \( sen(\theta) \)
                        no mesmo gráfico:</p>
                        <pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt

theta = np.linspace(-np.pi, np.pi, 30, endpoint=True)    # coordenadas de theta
y1 = np.cos(theta) # valores de y no cos
y2 = np.sin(theta) # valores de y no sen

plt.plot(theta, y1, 'g', label=r'$cos(\theta)$', linewidth=5) #linha vermelha com espessura de 5 em pontos
plt.plot(theta, y2, 'b-o', label=r'$sen(\theta)$') #azul com círculos

plt.xlabel(r'$\theta$')               # rótulo do eixo x
plt.ylabel('y')               # rótulo do eixo y
plt.legend(loc='best')   # gera a legenda e posiciona melhor
plt.title(u'Plotando duas curvas no mesmo gráfico')
plt.savefig('cos_sen.png')
                        </code></pre>
                        <p>Outras posições para a legenda são: right, center left,
                        upper right, lower right, best, center, lower left, center right,
                        upper left, upper center e lower center.</p>
                    </div>
                    <div class="bs-docs-section" id="controlando_graficos">
                        <h1 class="page-header">Controlando os estilos das linhas</h1>

                        <p>Quando são muitas as curvas a serem exibidas no mesmo
                        gráfico é interessante mudar o visual de cada curva.</p>
                        <p>Podemos controlar o tipo da linha, a cor, a espessura
                        e eventualmente marcadores sobre a curva se quisermos:</p>
                        <pre><code class="language-python">
plt.plot(theta, y1, 'r-', label=r'$cos(\theta)$', linewidth=5) #linha vermelha com espessura de 5 pontos
plt.plot(theta, y2, 'b-o', label=r'$sen(\theta)$') #azul com círculos
                        </code></pre>
                        <p>Lembando que os argumentos posicionais sempre devem
                        aparecer antes do argumentos palavra-chave. Se for
                        construído assim:</p>
                        <pre><code class="language-python">
plt.plot(t, y1, label=r'$cos(\theta)$', 'r-') #linha vermelha
                        </code></pre>
                        <p>Vai ser levantado um erro de sintaxe, pois <code>label</code>
                        é um argumento palavra-chave.</p>
                        <p>Além disso, para mostrar o gráfico em um novo console
                        você precisa ao final de todos os códigos, o comando 
                        <code>plt.show()</code>.</p>
                    </div>
                    <div class="bs-docs-section" id="controlando_graficos2">
                        <h1 class="page-header">Códigos para o estilo da linha e
                        marcadores</h1>

                        <p>Os códigos para estilo de linhas podem ser acessados com:</p>
                        <pre><code class="language-python">
import matplotlib.lines as lines
lines.lineStyles.keys()
>>> [u'', u' ', u'None', u'--', u'-.', u'-', u':']
                        </code></pre>
                        <p>Os códigos para estilo de marcadores também:</p>
                        <pre><code class="language-python">
import matplotlib.markers as markers
markers.MarkerStyle.markers.keys()
>>> [0, 1, 2, 3, 4, u'D', 6, 7, u's', u'|', u'', u'None',... u'<', u'>']
                        </code></pre>
                        <p>Os códigos para estilo de linha e de marcadores podem
                        ser combinados.</p>
                    </div>
                    <div class="bs-docs-section" id="controlando_graficos3">
                        <h1 class="page-header">Reorganizando os eixos e adicionando
                        anotações</h1>

                        <p>Podemos reposicionar os eixos e os marcadores de
                        cada eixo, com seus respectivos valores, para melhor
                        visualização:</p>
                        <pre><code class="language-python">
plt.xlim(-4.0, 4.0) #define os limites em x
plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi],
          [r'$-\pi$', r'$-\pi/2$', r'$0$', r'$+\pi/2$', r'$+\pi$']) #marcadores específicos

plt.ylim(-1.0, 1.0) #define os limites em y
plt.yticks([-1, 0, +1],
          [r'$-1$', r'$0$', r'$+1$']) #marcadores com nomes

ax = plt.gca()  # gca significa 'get current axis'
ax.spines['right'].set_color('none') #removendo o fechamento da direita
ax.spines['top'].set_color('none') #removendo o fechamento de cima
ax.xaxis.set_ticks_position('bottom') #mantendo os marcadores abaixo
ax.spines['bottom'].set_position(('data',0)) #movendo o limite inferior para 0 dos dados
ax.yaxis.set_ticks_position('left') #mantendo os marcadores à esquerda
ax.spines['left'].set_position(('data',0)) #movendo o limite da esquerda para 0 dos dados
                        </code></pre>                       
                        
                        <p>É possível também adicionar notas sobre o gráfico e
                        melhorar a visualização dos elementos:</p>
                        <pre><code class="language-python">
t = 2 * np.pi / 3
plt.plot([t, t], [0, np.cos(t)], color='blue', linewidth=2.5, linestyle="--")
plt.scatter([t, ], [np.cos(t), ], 50, color='blue')

plt.annotate(r'$sin(\frac{2\pi}{3})=\frac{\sqrt{3}}{2}$',
            xy=(t, np.sin(t)), xycoords='data',
            xytext=(+30, +5), textcoords='offset points', fontsize=16,
            arrowprops=dict(arrowstyle="->", connectionstyle="arc3,rad=.2"))

plt.plot([t, t],[0, np.sin(t)], color='red', linewidth=2.5, linestyle="--")
plt.scatter([t, ],[np.sin(t), ], 50, color='red')

plt.annotate(r'$cos(\frac{2\pi}{3})=-\frac{1}{2}$',
            xy=(t, np.cos(t)), xycoords='data',
            xytext=(-90, -50), textcoords='offset points', fontsize=16,
            arrowprops=dict(arrowstyle="->", connectionstyle="arc3,rad=.2"))

for label in ax.get_xticklabels() + ax.get_yticklabels():
    label.set_fontsize(16)
    label.set_bbox(dict(facecolor='white', edgecolor='None', alpha=0.65))
                        </code></pre>
                        
                    </div>
                    <div class="bs-docs-section" id="subplotagens">
                        <h1 class="page-header">Separando os gráficos</h1>

                        <p>É possível separarmos os gráficos em duas regiões
                        distintas, como sub-gráficos.</p>
                        <p>Para isso precisamos criar uma figura:</p>
                        <pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt

theta = np.linspace(-np.pi, np.pi, 30, endpoint=True)    # coordenadas de theta
y1 = np.cos(theta) # valores de y no cos
y2 = np.sin(theta) # valores de y no sen

# Cria uma figura de tamanho 8x6 pontos, 80 pontos por polegada
plt.figure(figsize=(8, 6), dpi=80)

# Cria um novo sub-gráfico a partir de um grid de 2x1 e posiciona no 1
plt.subplot(2, 1, 1)
plt.plot(theta, y1, 'g', label=r'$cos(\theta)$', linewidth=5) #linha vermelha com espessura de 5 em pontos

# Cria um novo sub-gráfico a partir de um grid de 2x1 e posiciona no 2
plt.subplot(2, 1, 2)
plt.plot(theta, y2, 'b-o', label=r'$sen(\theta)$') #azul com círculos
                        </code></pre>
                        <p>Todas as demais personalizações mostradas anteriomente
                        se aplicam a cada sub-gráfico.</p>
                    </div> 
                    <div class="bs-docs-section" id="grafico_funcao_desc">
                        <h1 class="page-header">Vamos tentar um gráfico
                        de uma função discontínua</h1>
                        
                        <p>A função Heaviside é frequentemente usada na
                        ciência e na engenharia:</p>
                        $$ H(x) = \left\lbrace\begin{array}{ll}
                        0, & x < 0\\
                        1, & x\geq 0
                        \end{array}\right.
                        $$
                        <p>Implementação em Python:</p>
                        <pre><code class="language-python">
def H(x):
    return (0 if x < 0 else 1)
                        </code></pre>
                        
                    </div>
                    <div class="bs-docs-section" id="grafico_funcao_desc-t1">
                        <h1 class="page-header">Gráfico da função Heaviside:
                        primeira tentativa</h1>
                        
                        <p>Abordagem padrão:</p>
                        <pre><code class="language-python">
x = linspace(-10, 10, 5)  # few points (simple curve)
y = H(x)
plot(x, y)
                        </code></pre>
                        <p>Primeiro problema: Erro de <code>ValueError</code> 
                            em H(x) do <code>if x < 0</code>.</p>
                        <p>O erro completo:</p>
                        <pre><code class="language-python">
return (0 if x < 0 else 1)

ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
                        </code></pre>
                        
                    </div>
                    <div class="bs-docs-section" id="grafico_funcao_desc-t2">
                        <h1 class="page-header"><code>if x < 0</code> não funciona
                            se <code>x</code> é um arranjo</h1>
                        
                        <p>Solução 1: usar um laço sobre os valores de <code>x</code></p>
                        <pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt

def H(x):
    return (0 if x < 0 else 1)

def H_loop(x):
    r = np.zeros(len(x))  # ou r = x.copy()
    for i in xrange(len(x)):
        r[i] = H(x[i])
    return r

n = 5
x = np.linspace(-5, 5, n+1)
y = H_loop(x)
plt.plot(x, y)
                        </code></pre>
                        <p>Muito código e lento se n é grande.</p>
                        
                        <p>Solução 2: usar a vetorização</p>
                        <pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt

def H(x):
    return (0 if x < 0 else 1)

# vetorização automática da função H
Hv = np.vectorize(H)
# Hv(x) funciona com o arranjo x

n = 5
x = np.linspace(-5, 5, n+1)
y = Hv(x)
plt.plot(x, y)
                        </code></pre>
                        <p>Continua sendo tão lento quanto a solução 1.</p>
                        
                        <p>Solução 3: escrever o teste <code>if</code> de forma 
                        diferente.</p>
                        <pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt

def Hv(x):
    return np.where(x < 0, 0.0, 1.0)

n = 5
x = np.linspace(-5, 5, n+1)
y = Hv(x)
plt.plot(x, y)
                        </code></pre>
                    </div>
                    <div class="bs-docs-section" id="grafico_funcao_desc_ver">
                        <h1 class="page-header">Como fazer a função aparecer
                        descontínua no gráfico?</h1>
                        
                        <ul>
                            <li>Amador: fazer um monte de pontos x;</li>
                            <li>Pro: fazer o gráfico com dois segmentos de
                            linha horizontais, um de x=-10 até x=0, com y=0 e
                            outro de x=0 até x=10, com y=1:</li>
                        </ul>
                        <pre><code class="language-python">
import matplotlib.pyplot as plt

plt.xlim(-10, 10)
plt.ylim(-0.1, 1.1)
plt.plot([-10, 0, 0, 10], [0, 0, 1, 1])
                        </code></pre>
                        
                    </div>
                    <div class="bs-docs-section" id="funcoes_dificeis_graf">
                        <h1 class="page-header">Algumas funções são difíceis de
                        se visualizar</h1>
                        
                        <p>Faça o gráfico de $f(x) = sen(\dfrac{1}{x})$:</p>
                        <pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt

def f(x):
    return np.sin(1.0/x)

x1 = np.linspace(-1, 1, 10)    # uso de 10 pontos, azul
x2 = np.linspace(-1, 1, 1000)  # uso de 1000 pontos, verde
plt.plot(x1, f(x1), label='%d points' % len(x1))
plt.plot(x2, f(x2), label='%d points' % len(x2))
                        </code></pre>
                        <div class="text-center">
                            <img width="500" src="./imagens/seno10-1000.png" alt="Gráfico senos">
                        </div>
                        
                    </div>
                    <div class="bs-docs-section" id="atribuicao_array">
                        <h1 class="page-header">Atribuição de um arranjo não copia os elementos!</h1>
                        
                        <pre><code class="language-python">
x = np.linspace(0, 10, 11)
a = x
a[-1] = 1000
                        </code></pre>
                        <p><code>x[-1]</code> também se modifica para 1000?</p>
                        <p>Sim, porque arranjos são mutáveis! Da mesma forma que 
                        listas.</p>
                        <p>Para evitar isso, pode-se criar uma cópia:</p>
                        <pre><code class="language-python">
a = x.copy()
                        </code></pre>
                        <p>O mesmo ocorre para os cortes:</p>
                        <pre><code class="language-python">
a = x[4:]      # a é uma visualização de parte de x
a[-1] = 1000   # muda x[-1]!
a = x[4:].copy()
a[-1] = 1000   # não muda x[-1]
                        </code></pre>
                    </div>
                    <div class="bs-docs-section" id="arranjo_elemento_elemento">
                        <h1 class="page-header">Operações elemento-a-elemento em 
                        arranjos</h1>
                        
                        <p>As duas seguintes declarações são matematicamente
                        equivalentes:</p>
                        <pre><code class="language-python">
a = a + b    # a e b são arranjos (arrays)
a += b
                        </code></pre>
                        <p>No entanto:</p>
                        <ul>
                            <li><code>a = a + b</code> é calculado como:
                                <ul>
                                    <li><code>r1 = a + b</code></li>
                                    <li><code>a = r1</code></li>
                                </ul>                                    
                            </li>
                            <li><code>a += b</code> é calculado como <code>a[i] += b[i]</code> para todos
                            os índices;</li>
                            <li><code>a += b</code> é uma adição elemento-a-elemento, pois modifica
                            todo elemento de <code>a</code>, além de resultar em um novo arranjo,
                            o resultado de <code>a + b</code></li>
                        </ul>
                        
                    </div>
                    <div class="bs-docs-section" id="arranjo_elemento_elemento_memoria">
                        <h1 class="page-header">Operações elemento-a-elemento podem
                        reduzir o consumo de memória</h1>
                        
                        <p>Considere:</p>
                        <pre><code class="language-python">
a = (3*x**4 + 2*x + 4)/(x + 1)
                        </code></pre>
                        <p>Essas são os cálculos efetuados pelo computador:</p>
                        <pre><code class="language-python">
r1 = x**4;  r2 = 3*r1;  r3 = 2*x;  r4 = r1 + r3
r5 = r4 + 4;  r6 = x + 1; r7 = r5/r6; a = r7
                        </code></pre>
                        <p>Com as operações elemento-a-elemento pode-se eliminar
                        4 arranjos extras:</p>
                        <pre><code class="language-python">
a = x.copy()
a **= 4
a *= 3
a += 2*x
a += 4
a /= x + 1
                        </code></pre>
                    </div>
                    <div class="bs-docs-section" id="arranjo_elemento_elemento_memoria_vel">
                        <h1 class="page-header">Economiza memória mas não acelera tanto
                        o código</h1>
                        
                        <p>Vamos medir o tempo computacional entre os dois:</p>
                        <pre><code class="language-python">
In [1]: def expression(x):
   ...:     return (3*x**4 + 2*x + 4)/(x + 1)
   ...:

In [2]: def expression_inplace(x):
   ...:     a = x.copy()
   ...:     a **= 4
   ...:     a *= 3
   ...:     a += 2*x
   ...:     a += 4
   ...:     a /= x + 1
   ...:     return a
   ...:

In [3]: import numpy as np

In [4]: x = np.linspace(0, 1, 10000000)

In [5]: %timeit  expression(x)
1 loops, best of 3: 771 ms per loop

In [6]: %timeit  expression_inplace(x)
1 loops, best of 3: 728 ms per loop
                        </code></pre>
                        <p>Apenas 5% de ganho de velocidade. Quando os arranjos
                        são grandes, você precisa economizar memória!</p>
                    </div>
                    <div class="bs-docs-section" id="operacoes_arranjos">
                        <h1 class="page-header">Operações úteis com arranjos</h1>
                        
                        <p>Faça um novo arranjo do mesmo tamanho que outro:</p>
                        <pre><code class="language-python">
import numpy as np

x = np.linspace(0, 1, 100)

# x is numpy array
a = x.copy()

# ou
a = np.zeros(x.shape, x.dtype)

# ou
a = np.zeros_like(x)  # zeros e o mesmo tamanho de x
                        </code></pre>
                        <p>Convertendo para arranjos:</p>
                        <pre><code class="language-python">
a = asarray(a)
b = asarray(algumArranjo, dtype=float)  # especificando o tipo dos dados
                        </code></pre>
                        <p>Testando se um objeto é um arranjo:</p>
                        <pre><code class="language-python">
>>> type(a)
&lt;type 'numpy.ndarray'&gt;
>>> isinstance(a, ndarray)
True
                        </code></pre>
                    </div>
                    <div class="bs-docs-section" id="vetorizando_funcao">
                        <h1 class="page-header">Exemplo: vetorizando uma função 
                            constante</h1>                                        
                        
                        <pre><code class="language-python">
def f(x):
    return 2
                        </code></pre>
                        <p>A função vetorizada deve retornar 2.</p>
                        <pre><code class="language-python">
def fv(x):
    return zeros(x.shape, x.dtype) + 2
                        </code></pre>
                        <p>Versão mais completa, válida para escalares e arranjos:</p>
                        <pre><code class="language-python">
def f(x):
    if isinstance(x, (float, int)):
        return 2
    elif isinstance(x, ndarray):
        return zeros(x.shape, x.dtype) + 2
    else:
        raise TypeError(
           'x must be int/float/ndarray, not %s' % type(x))
                        </code></pre>
                        
                    </div>
                    <div class="bs-docs-section" id="indexacao_arranjos">
                        <h1 class="page-header">Indexação generalizada de arranjos</h1>
                        
                        <p>Lembra-se da forma de corte: <code>a[f:t:i]</code> onde
                        f, t e i são os índices início, fim e incremento?</p>
                        <p>Qualquer lista ou arranjo de inteiros pode ser utilizado
                        para indicar um conjunto de índices:</p>
                        <pre><code class="language-python">
>>> a = linspace(1, 8, 8)
>>> a
array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])
>>> a[[1,6,7]] = 10
>>> a
array([  1.,  10.,   3.,   4.,   5.,   6.,  10.,  10.])
>>> a[range(2,8,3)] = -2   # mesmo que a[2:8:3] = -2
>>> a
array([  1.,  10.,  -2.,   4.,   5.,  -2.,  10.,  10.])
                        </code></pre>
                        
                    </div>   
                    <div class="bs-docs-section" id="indexacao_arranjos_bool">
                        <h1 class="page-header">Indexação generalizada de arranjos
                        com expressões boleanas</h1>
                        
                        <pre><code class="language-python">
>>> a < 0
[False, False, True, False, False, True, False, False]

>>> a[a < 0]           # todos os elementos negativos
array([-2., -2.])

>>> a[a < 0] = a.max() # se a[i]<10, faça a[i]=10
>>> a
array([  1.,  10.,  10.,   4.,   5.,  10.,  10.,  10.])
                        </code></pre>                    
                    </div> 
                    <div class="bs-docs-section" id="arranjos_bidimensionais">
                        <h1 class="page-header">Arranjos bidimensionais</h1>
                        
                        <p>Fazendo e preenchendo um arranjo bidimensional do
                        numpy:</p>
                        <pre><code class="language-python">
A = zeros((3,4))   # tabela de números 3x4
A[0,0] = -1
A[1,0] =  1
A[2,0] = 10
A[0,1] = -5
...
A[2,3] = -100
                        </code></pre> 
                    </div> 
                    <div class="bs-docs-section" id="listaParaArranjo">
                        <h1 class="page-header">De uma lista para um arranjo</h1>
                        
                        <p>Vamos fazer uma tabela de números em uma lista de
                        listas:</p>
                        <pre><code class="language-python">
>>> Cgraus = [-30 + i*10 for i in range(3)]
>>> Fgraus = [9./5*C + 32 for C in Cgrauss]
>>> tabela = [[C, F] for C, F in zip(Cgrauss, Fgraus)]
>>> print tabela
[[-30, -22.0], [-20, -4.0], [-10, 14.0]]
                        </code></pre> 
                        <p>Convertendo em arranjo (NumPy array):</p>
                        <pre><code class="language-python">
>>> tabela2 = array(tabela)
>>> print tabela2
[[-30. -22.]
 [-20.  -4.]
 [-10.  14.]]
                        </code></pre> 
                        
                    </div> 
                    <div class="bs-docs-section" id="arranjo_bidi_laco">
                        <h1 class="page-header">Como corre um laço
                        sobre um arranjo bidimensional</h1>
                        
                        <pre><code class="language-python">
>>> tabela2.shape   # o numero de elementos por direção
(3, 2)             # 3 linhas, 2 colunas
                        </code></pre>
                        <p>Um laço sobre todos os elementos do arranjo:</p>
                        <pre><code class="language-python">
>>> for i in range(tabela2.shape[0]):
...     for j in range(tabela2.shape[1]):
...         print 'tabela2[%d,%d] = %g' % (i, j, tabela2[i,j])
...
tabela2[0,0] = -30
tabela2[0,1] = -22
...
tabela2[2,1] = 14
                        </code></pre>
                        <p>Uma forma alternativa com único laço:</p>
                        <pre><code class="language-python">
>> for tupla_indice, valor in np.ndenumerate(tabela2):
...     print 'indice %s tem valor %g' % \
...           (tupla_indice, tabela2[tupla_indice])
...
indice (0,0) tem valor -30
indice (0,1) tem valor -22
...
indice (2,1) tem valor 14
>>> type(tupla_indice)
&lt;type 'tuple'&gt;
                        </code></pre>
                    </div> 
                    <div class="bs-docs-section" id="arranjo_bidi_cortes">
                        <h1 class="page-header">Como fazer cortes em arranjos
                        bidimensionais</h1>
                        
                        <p>Regra: podemos usar cortes no formato inicio:fim:incremento</p>
                        <pre><code class="language-python">
tabela2[0:tabela2.shape[0], 1]  # 2 coluna (indice 1)
array([-22.,  -4.,  14.])

>>> tabela2[0:, 1]             # mesmo
array([-22.,  -4.,  14.])

>>> tabela2[:, 1]              # mesmo
array([-22.,  -4.,  14.])

>>> t = linspace(1, 30, 30).reshape(5, 6)
>>> t[1:-1:2, 2:]
array([[  9.,  10.,  11.,  12.],
       [ 21.,  22.,  23.,  24.]])
>>> t
array([[  1.,   2.,   3.,   4.,   5.,   6.],
       [  7.,   8.,   9.,  10.,  11.,  12.],
       [ 13.,  14.,  15.,  16.,  17.,  18.],
       [ 19.,  20.,  21.,  22.,  23.,  24.],
       [ 25.,  26.,  27.,  28.,  29.,  30.]])
                        </code></pre>
                        <p>Sendo o <code>t</code> acima, o que <code>t[1:-1:2, 2:]</code> será?</p>
                    </div>
                    <div class="bs-docs-section" id="arranjos_reducoes">
                        <h1 class="page-header">Reduções básicas</h1>
                        
                        <p>Calculando somas:</p>
                        <pre><code class="language-python">
x = np.array([1, 2, 3, 4])
np.sum(x)
x.sum()
                        </code></pre>
                        <p>Soma por linha e por coluna:</p>
                        <pre><code class="language-python">
x = np.array([[1, 1], [2, 2]])
x
x.sum(axis=0)   # colunas (primeira dimensão)
x[:, 0].sum(), x[:, 1].sum()
x.sum(axis=1)   # linhas (segunda dimensão)
x[0, :].sum(), x[1, :].sum()
                        </code></pre>
                        <p>A ideia é a mesma em maiores dimensões:</p>
                        <pre><code class="language-python">
x = np.random.rand(2, 2, 2)
x.sum(axis=2)[0, 1]     
x[0, 1, :].sum()
                        </code></pre>
                        <p>Extremos:</p>
                        <pre><code class="language-python">
x = np.array([1, 3, 2])
x.min()
x.max()
x.argmin()  # índice do mínimo
x.argmax()  # índice do máximo
                        </code></pre>
                        <p>Comparações de arranjos:</p>
                        <pre><code class="language-python">
a = np.zeros((100, 100))
np.any(a != 0)
np.all(a == a)
a = np.array([1, 2, 3, 2])
b = np.array([2, 2, 3, 2])
c = np.array([6, 4, 4, 5])
((a <= b) & (b <= c)).all()
                        </code></pre>                                                
                    </div>
                    <div class="bs-docs-section" id="transmissao-broadcasting_arranjos">
                        <h1 class="page-header">Transmissão</h1>

                        <ul>
                            <li>As operações básicas nos arranjos do NumPy 
                                são elemento a elemento;</li>
                            <li>Essas operações só funcionam em arranjos de mesmo 
                                tamanho, no entanto, é possível fazer operações 
                                em arranjos de diferentes tamanhos se o NumPy puder 
                                transformá-las para que todas tenham o mesmo 
                                tamanho: essa convenção é chamada de transmissão (Broadcasting).</li>
                        </ul>
                        <p>A imagem abaixo dá um exemplo de broadcasting:</p>
                        <div class="text-center">
                            <img width="700" src="./imagens/numpy_broadcasting.png" alt="Transmissão">
                        </div>
                        <p>Verificando:</p>
                        <pre><code class="language-python">
a = np.tile(np.arange(0, 40, 10), (3, 1)).T
a
b = np.array([0, 1, 2])
a + b
                        </code></pre> 
                        <p>Um truque útil:</p>
                        <pre><code class="language-python">
a = np.arange(0, 40, 10)
a.shape
a = a[:, np.newaxis]  # adiciona um novo eixo -> array 2D
a.shape
a
a + b
                        </code></pre>
                        <p>Ou seja, acabamos de utilizar a transmissão sem saber:</p>
                        <pre><code class="language-python">
a = np.ones((4, 5))
a[0] = 2  # atribuimos uma array de dimensão 0 a uma array de dimensão 1
a
                        </code></pre>
                        <p>Transmissão parece ser um pouco mágico, mas na verdade 
                            é bem natural utilizá-lo quando se deseja resolver um 
                            problema no qual os dados de saída são um arranjo com 
                            mais dimensões que os dados de entrada.</p>
                        <p>Vários problemas do tipo grid-based ou netword-bases 
                            podem também utilizar transmissão. Por exemplo, 
                            se desejarmos calcular a distância da origem aos 
                            pontos em um grid de 10x10, podemos fazer:</p>
                        <pre><code class="language-python">
x, y = np.arange(5), np.arange(5)
distance = np.sqrt(x ** 2 + y[:, np.newaxis] ** 2)
distance
                        </code></pre>
                        <p>Ou, em cores:</p>
                        <pre><code class="language-python">
plt.pcolor(distance)    
plt.colorbar()
                        </code></pre>
                        <p>Detalhe: a função <code>np.pgrid</code> permite criar 
                            diretamento vetores x e y do exemplo anterior com 
                            duas “dimensões significativas”.</p>
                        <pre><code class="language-python">
x, y = np.ogrid[0:5, 0:5]
x, y
x.shape, y.shape
distance = np.sqrt(x ** 2 + y ** 2)
                        </code></pre>
                    </div>
                    
                    AQUI!!!!!!!!
                    .... em estruturas.ufpr
                    
                    
                    <div class="bs-docs-section" id="final">
                        <h1 class="page-header">Tarefa</h1>
                        <p>
                            descrição...
                        </p>                        

                        <!--SOLUÇÃO DA TAREFA-->
                        <button type="button" class="btn btn-info disabled">Solução</button>                        
                        <!--<button type="button" class="btn btn-info" data-toggle="collapse" data-target="#tarefa">Solução</button>-->
                        <!--Final solução da tarefa-->                        

                        <div id="tarefa" class="collapse">
                            <h3> Exemplo de solução: </h3>

                            <pre><code class="language-python">g = 9.81    # m/s**2</code></pre>
                        </div>

                    </div>
                    
                </div>
                <!-- FINAL Conteúdo Principal -->
                
                <!-- Menu lateral -->
                <div class="col-md-3" role="complementary"> 
                    <nav class="bs-docs-sidebar hidden-print hidden-sm hidden-xs affix-top" id="menuLateral"> 
                        <ul class="nav bs-docs-sidenav"> 
                            <li><a href="#inicio">Arranjos e gráficos de curvas</a></li>
                        </ul> 
                        <a href="#top" class="back-to-top"> Voltar ao topo </a>                 
                    </nav> 
                </div>
                <!-- FINAL Menu lateral -->
                
            </div>
        </div>
        <!-- FINALParte principal -->
        
        <!-- Rodapé -->
        <footer class="bs-docs-footer"> 
            <div class="container"> 
                <ul class="bs-docs-footer-links"> 
                    <li><a href="http://www.estruturas.ufpr.br" target="_blank">estruturas.UFPR</a></li> 
                    <li><a href="http://www.estruturas.ufpr.br/disciplinas/pos-graduacao/introducao-a-computacao-cientifica-com-python/" target="_blank">Introdução à computação científica</a></li> 
                    <li><a href="https://www.python.org/" target="_blank">Python.org</a></li> 
                    <li><a href="https://www.python.org/dev/peps/pep-0257/" target="_blank">Docstring Conventions</a></li> 
                </ul> 
                <p>
                    Prof. Marco André Argenta
                </p> 
            </div> 
        </footer>
        <!-- FINAL Rodapé -->        
        
        <script src="../adicionais/jquery.min.js"></script>
        <script src="../adicionais/bootstrap.min.js"></script>
        <script src="./js/docs.min.js"></script>
        <script src="./js/prism.js"></script>
    </body>
</html>

